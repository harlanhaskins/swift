#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringSwitch.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Signals.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Main.h"
#include "llvm/TableGen/Record.h"
#include "swift/Basic/StringExtras.h"

using namespace llvm;

enum class ActionType {
  None,
  GenImplementation,
  GenInterface,
};

enum class Category {
  Unknown,
  DeclSyntax,
  ExprSyntax,
  StmtSyntax,
  TypeSyntax,
  TokenSyntax,
  PatternSyntax,
  GenericSyntax,
  AttributeSyntax,
  CommonSyntax,
  SyntaxFactory,
  SyntaxRewriter,
};

enum class TargetLanguage {
  CPlusPlus,
  Swift
};

static RecordKeeper *AllRecords;
static SmallSet<const Record *, 8> SyntaxCategories;

namespace options {
  static cl::opt<ActionType> Action(
    cl::desc("Action to perform: "),
    cl::init(ActionType::None),
    cl::values(
      clEnumValN(ActionType::GenImplementation, "implementation",
                 "Generate the implementation for the given syntax category"),
      clEnumValN(ActionType::GenInterface, "interface",
                 "Generate the interface for the given syntax category")));
  static cl::opt<TargetLanguage> Language(
    "language",
    cl::desc("Target language to emit: "),
    cl::init(TargetLanguage::CPlusPlus),
    cl::values(
      clEnumValN(TargetLanguage::CPlusPlus, "c++",
                 "Generate the interface or implementation in C++"),
      clEnumValN(TargetLanguage::Swift, "swift",
                 "Generate the interface or implementation in Swift")));
  static cl::opt<std::string> Category("category",
                                       cl::desc("Category to emit"));
} // end options namespace

bool isKeyword(StringRef name) {
  return llvm::StringSwitch<bool>(name)
#define KEYWORD(Id) .Case(#Id, true)
#include "swift/Syntax/TokenKinds.def"
  .Default(false);
}

std::string sanitized(StringRef name) {
  llvm::SmallString<20> scratch;
  std::string word = swift::camel_case::toLowercaseWord(name, scratch);
  if (isKeyword(word)) {
    word = "`" + word + "`";
  }
  return word;
}

static void printAutogenReminder(raw_ostream &OS) {
  OS << "/// This file autogenerated by swift-syntax-tblgen - DO NOT EDIT!\n";
  OS << "\n";
}

/// Returns true if the record type is a subclass of Syntax.
/// Used to filter out values in a record that tablegen automatically inserts, like NAME,
/// or auxiliary fields that we have added, like IsRequired.
static bool is(const Record &Rec, StringRef TypeName) {
  if (Rec.getName() == TypeName || Rec.isSubClassOf(AllRecords->getClass(TypeName))) {
    return true;
  }
  return false;
}

static bool isBaseSyntaxClass(const Record &Node) {
  return llvm::StringSwitch<bool>(Node.getName())
  .Case("DeclSyntax", true)
  .Case("ExprSyntax", true)
  .Case("StmtSyntax", true)
  .Case("TypeSyntax", true)
  .Case("PatternSyntax", true)
  .Default(false);
}

static bool isToken(const Record &Rec) {
  return is(Rec, "TokenSyntax");
}

static bool isIdentifier(const Record &Rec) {
  return is(Rec, "Identifier");
}

static bool isLayout(const Record &Rec) {
  return is(Rec, "Layout");
}

/// For a given child value of Layout<T>, return the record for T, which
/// represents a concrete definition of a syntax node.
static const Record *getChildRecord(const RecordVal &Child) {
  if (const auto *DI = dyn_cast<DefInit>(Child.getValue())) {
    return DI->getDef();
  }
  return nullptr;
}

static const Record *getGeneratingCategoryRecord() {
  return AllRecords->getDef(options::Category);
}

static const Record &getTokenSyntaxRecord() {
  return *AllRecords->getClass("TokenSyntax")->getDefInit()->getDef();
}

bool canBeAnyOfSyntaxCategory(const Record &Rec) {
  return Rec.getName().startswith("Any");
}

/// For a given child record of Layout<T>, return the record for T, which
/// represents a concrete definition of a syntax node.
static const Record &getLayoutNodeRecord(const Record &Rec) {
  assert(isLayout(Rec));
  const auto NodeField = *Rec.getValue("Node");
  return *getChildRecord(NodeField);
}

static const Record &getLayoutNodeRecord(const RecordVal &Child) {
  return getLayoutNodeRecord(*getChildRecord(Child));
}

static const Record *getBaseSyntaxCategory(const Record &Child) {
  for (const auto &Super : Child.getSuperClasses()) {
    if (isBaseSyntaxClass(*Super.first)) {
      return Super.first;
    }
  }
  return nullptr;
}

static const StringRef getChildTypeName(const Record &Rec) {
  if (isToken(Rec)) {
    return "TokenSyntax";
  }
  if (canBeAnyOfSyntaxCategory(Rec)) {
    if (auto BaseCategory = getBaseSyntaxCategory(Rec)) {
      return BaseCategory->getName();
    }
  }
  return Rec.getName();
}

static const Record &
getSyntaxCategory(const Record &Def) {
  if (isLayout(Def)) {
    auto LayoutNode = Def.getValue("Node");
    return *getChildRecord(*LayoutNode);
  }
  for (const auto &Super : Def.getSuperClasses()) {
    if (SyntaxCategories.count(Super.first)) {
      return *Super.first;
    }
  }
  llvm_unreachable("Record didn't have a syntax category??");
}

static StringRef getTokenSpelling(const Record &TokenRec) {
  assert(isToken(TokenRec));
  for (const auto &Field : TokenRec.getValues()) {
    if (Field.getName() == "Spelling") {
      return Field.getValue()->getAsUnquotedString();
    }
  }
  return StringRef();
}

static StringRef stripSyntaxSuffix(StringRef TypeName) {
  auto Pos = TypeName.rfind("Syntax");
  if (Pos == StringRef::npos) {
    return TypeName;
  }
  return TypeName.slice(0, Pos);
}

static std::string getMissingSyntaxKind(const RecordVal &Child) {
  // TODO
  if (auto Rec = getChildRecord(Child)) {
    std::string Name = stripSyntaxSuffix(getSyntaxCategory(*Rec).getName());
    return "Missing" + Name;
  }
  return "Missing";
}

static Category getCategory() {
  return llvm::StringSwitch<Category>(options::Category)
  .Case("DeclSyntax", Category::DeclSyntax)
  .Case("ExprSyntax", Category::ExprSyntax)
  .Case("StmtSyntax", Category::StmtSyntax)
  .Case("TypeSyntax", Category::TypeSyntax)
  .Case("TokenSyntax", Category::TokenSyntax)
  .Case("PatternSyntax", Category::PatternSyntax)
  .Case("GenericSyntax", Category::GenericSyntax)
  .Case("AttributeSyntax", Category::AttributeSyntax)
  .Case("CommonSyntax", Category::CommonSyntax)
  .Case("SyntaxFactory", Category::SyntaxFactory)
  .Case("SyntaxRewriter", Category::SyntaxRewriter)
  .Default(Category::Unknown);
}

static bool categoryHasBaseClass() {
  switch (getCategory()) {
    case Category::DeclSyntax:
    case Category::ExprSyntax:
    case Category::PatternSyntax:
    case Category::StmtSyntax:
    case Category::TypeSyntax:
      return true;
    default:
      return false;
  }
}

static bool categoryIsInSyntaxHierarchy() {
  switch (getCategory()) {
    case Category::DeclSyntax:
    case Category::ExprSyntax:
    case Category::PatternSyntax:
    case Category::StmtSyntax:
    case Category::TypeSyntax:
    case Category::GenericSyntax:
    case Category::AttributeSyntax:
    case Category::CommonSyntax:
      return true;
    default:
      return false;
  }
}

static std::vector<RecordVal> getChildrenOf(const Record &Node) {
  std::vector<RecordVal> Children;
  
  for (const auto &Child : Node.getValues()) {
    if (auto ChildRec = getChildRecord(Child)) {
      if (!isLayout(*ChildRec)) {
        continue;
      }
      Children.push_back(Child);
    }
  }
  
  return Children;
}

/// Returns the records for a category that we should print code for.
static std::vector<const Record *>
getRecordsForCategory(const std::string &Category) {
  std::vector<const Record *> Records;
  for (const auto &NameAndRec : AllRecords->getDefs()) {
    if (NameAndRec.second->getName().startswith("Any")) {
      continue;
    }
    if (NameAndRec.second->isAnonymous()) {
      continue;
    }
    if (NameAndRec.second->getValueAsString("Category") != options::Category) {
      continue;
    }
    Records.push_back(NameAndRec.second.get());
  }
  return Records;
}

/// Returns the records referenced by this category's records, used
/// for printing forward declarations, for example.
static std::set<const Record *>
getRecordsReferencedByCategory(const std::string &Category) {
  std::set<const Record *> ReferencedRecords;
  auto Nodes = getRecordsForCategory(Category);
  for (const auto *Node : Nodes) {
    for (const auto &Child : getChildrenOf(*Node)) {
      const auto &ChildType = getLayoutNodeRecord(Child);
      if (isToken(ChildType)) {
        continue;
      }
      if (canBeAnyOfSyntaxCategory(ChildType)) {
        if (const auto *Base = getBaseSyntaxCategory(ChildType)) {
          ReferencedRecords.insert(Base);
          continue;
        }
      }
      if (std::find(Nodes.begin(), Nodes.end(), &ChildType) == Nodes.end()) {
        ReferencedRecords.insert(&ChildType);
      }
    }
  }
  return ReferencedRecords;
}

class SyntaxImplementationGenerator {
protected:
  raw_ostream &OS;
  TargetLanguage Language;

public:
  SyntaxImplementationGenerator(raw_ostream &OS, TargetLanguage Language):
    OS(OS), Language(Language) {}

  virtual void printIncludesOfImplementation() {}
  virtual bool printSyntaxInterfaces() {

    return false;
  }

  virtual bool printSyntaxImplementations() {
    const auto Nodes = getRecordsForCategory(options::Category);
    printAutogenReminder(OS);
    for (const auto *Node : Nodes) {
      printPragma(Node->getName().str() + " Data");
      printSyntaxDataImplementation(*Node);
      printPragma(Node->getName().str() + " API");
      printSyntaxImplementation(*Node);
    }
    return false;
  }

  virtual bool printSyntaxDataInterface(const Record &Node) { return false; }
  virtual bool printSyntaxDataImplementation(const Record &Node) {
    return false;
  }

  virtual bool printSyntaxInterface(const Record &Node) { return false; }
  virtual bool printSyntaxImplementation(const Record &Node) {
    return false;
  }

  virtual bool printSyntaxDataInterfaces() {
    // Print the interface of the "base" category classes, such as 'Stmt', 'Expr',
    // etc.
    if (categoryHasBaseClass()) {
      auto CategoryRecord = AllRecords->getClass(options::Category);
      printSyntaxDataInterface(*CategoryRecord);
      printSyntaxInterface(*CategoryRecord);
    }

    const auto Nodes = getRecordsForCategory(options::Category);
    for (const auto *Node : Nodes) {
      printSyntaxDataInterface(*Node);
      printSyntaxInterface(*Node);
    }
    return false;
  }

  virtual bool printSyntaxFactoryInterface() { return false; }
  virtual bool printSyntaxFactoryImplementation() { return false; }
  virtual bool printSyntaxRewriterInterface() { return false; }
  virtual bool printSyntaxRewriterImplementation() { return false; }

  virtual void printPragma(std::string MarkName) {}

  virtual void printTokenAssertion(std::string VariableName,
                                   const Record &TokenRec) {}

  virtual void printSyntaxAssertion(Twine ChildVariable,
                                    const RecordVal Child) {}

  bool genInterface() {
    switch (getCategory()) {
      case Category::DeclSyntax:
      case Category::ExprSyntax:
      case Category::StmtSyntax:
      case Category::TypeSyntax:
      case Category::PatternSyntax:
      case Category::GenericSyntax:
      case Category::AttributeSyntax:
      case Category::TokenSyntax:
      case Category::CommonSyntax:
        return printSyntaxInterfaces();
        break;
      case Category::SyntaxFactory:
        return printSyntaxFactoryInterface();
        break;
      case Category::SyntaxRewriter:
        return printSyntaxRewriterInterface();
        break;
      case Category::Unknown:
        llvm_unreachable("Unknown category given");
    }
  }

  bool genImplementation() {
    printIncludesOfImplementation();

    switch (getCategory()) {
      case Category::DeclSyntax:
      case Category::ExprSyntax:
      case Category::StmtSyntax:
      case Category::TypeSyntax:
      case Category::PatternSyntax:
      case Category::GenericSyntax:
      case Category::AttributeSyntax:
      case Category::TokenSyntax:
      case Category::CommonSyntax:
        return printSyntaxImplementations();
      case Category::SyntaxFactory:
        return printSyntaxFactoryImplementation();
      case Category::SyntaxRewriter:
        return printSyntaxRewriterImplementation();
      case Category::Unknown:
        llvm_unreachable("Unknown category given");
    }
  }

  TargetLanguage getTargetLanguage() {
    return Language;
  }

  virtual ~SyntaxImplementationGenerator() {}
};

#pragma mark - Swift Generator

class SwiftSyntaxGenerator: public SyntaxImplementationGenerator {
public:
  SwiftSyntaxGenerator(raw_ostream &OS):
    SyntaxImplementationGenerator(OS, TargetLanguage::Swift) {}


  std::string getCursorName(const RecordVal &Child, bool VariableName = true) {
    auto ChildName = Child.getName().str();
    auto ChildRec = getLayoutNodeRecord(Child);
    if (isToken(ChildRec)) {
      ChildName = ChildName + "Token";
    }
    return VariableName ? sanitized(ChildName) : ChildName;
  }

  virtual void printIncludesOfImplementation() {}

  virtual bool printSyntaxImplementation(const Record &Node) {
    auto ClassName = Node.getName();
    llvm::SmallVector<std::string, 10> CursorNames;

    OS << "public class " << ClassName << ": Syntax {\n"
          "  private var data: " << ClassName << "Data {\n"
          "    return unsafeDowncast(_data, to: " << ClassName << "Data.self)\n"
          "  }\n\n"
          // Create a class var override for the data type underlying
          // this syntax node.
          "  override class var dataType: SyntaxData.Type {\n"
          "    return " << ClassName << "Data.self\n"
          "  }\n\n";
    for (auto Child : getChildrenOf(Node)) {
      auto ChildName = getCursorName(Child);
      CursorNames.emplace_back(ChildName);
      
      auto ChildCapName = getCursorName(Child, /*isVariable*/ false);
      auto ChildType = getLayoutNodeRecord(Child);
      auto ChildTypeName = getChildTypeName(ChildType);

      // Getter
      OS << "  public var " << ChildName << ": " << ChildTypeName << " {\n"
            "    return " << ChildTypeName << "(root: validRoot, data: data." << ChildName << ")\n"
            "  }\n\n";

      // Setter
      auto NewChildParam = "new" + ChildCapName;
      OS << "  public func with" << ChildCapName << "(_ " << NewChildParam
         << ": " << ChildTypeName << ") -> " << ClassName << " {\n";
      if (isToken(ChildType)) {
        auto RawNewChild = NewChildParam + ".data.raw";
        printTokenAssertion(RawNewChild, ChildType);
      }
      OS << "    let (root, newData) = data.replacingChild(" << NewChildParam << ".raw,\n"
            "                                              at: " << ClassName << "Data.Cursor." << ChildName << ")\n"
            "    return " << ClassName << "(root: root, data: newData)\n";
      OS << "  }\n\n";
    }
    
    // Create a class create() method to avoid a required initializer that would
    // expose SyntaxData.
    OS << "  override class func create(root: SyntaxData?, data: SyntaxData) -> Self {\n"
          "    return .init(root: root, data: data)\n"
          "  }\n\n";
    
    if (!CursorNames.empty()) {
      // Create an accessor for the child at a given index.
      OS << "  override func child(at index: Int) -> SyntaxData? {\n"
            "    guard let cursor = " << ClassName << "Data.Cursor(rawValue: index) else {\n"
            "      return nil\n"
            "    }\n\n"
            "    switch cursor {\n";
      for (const auto &Cursor : CursorNames) {
        OS << "    case ." << Cursor << ": return " << Cursor << "\n";
      }
      OS << "    }\n"
            "  }\n\n";
    }
    OS << "}\n\n";
    return false;
  }

  virtual bool printSyntaxFactoryInterface() { return false; }
  virtual bool printSyntaxFactoryImplementation() {
    // TODO: Fill this out
    return false;
  }
  virtual bool printSyntaxRewriterInterface() { return false; }
  virtual bool printSyntaxRewriterImplementation() {
    // TODO: Fill this out
    return false;
  }

  virtual void printTokenAssertion(std::string VariableName,
                                   const Record &TokenRec) {
    assert(isToken(TokenRec));
    auto Kind = TokenRec.getValueAsString("Kind");
    if (canBeAnyOfSyntaxCategory(TokenRec)) {
      OS << "    precondition(" << VariableName << ".isToken)\n";
    } else {
      OS << "    guard case ." << sanitized(Kind) << "? = (" << VariableName
      << " as? RawTokenSyntax)?.tokenKind else {\n"
      "      fatalError(\"incorrect token kind\")\n"
      "    }\n\n";
    }
  }

  virtual void printSyntaxAssertion(Twine ChildVariable,
                                    const RecordVal Child) {
    auto NodeType = getLayoutNodeRecord(Child);
    auto NodeTypeName = NodeType.getName();
    auto NodeKind = stripSyntaxSuffix(NodeTypeName);
    if (canBeAnyOfSyntaxCategory(NodeType)) {
      auto &Category = getSyntaxCategory(NodeType);
      OS << "    precondition(" << ChildVariable << ".is"
      << Category.getName() << ")\n";
    } else {
      OS << "    precondition(" << ChildVariable << ".kind == ."
      << sanitized(NodeKind) << ")\n";
    }
  }

  virtual void printPragma(std::string Mark) {
    OS << "/// MARK: " << Mark << "\n\n";
  }

  virtual bool printSyntaxDataImplementation(const Record &Node) {
    auto ClassName = Node.getName();
    auto Kind = stripSyntaxSuffix(ClassName);
    auto KindEnumCase = sanitized(Kind);
    auto SuperclassName = Node.getSuperClasses().back().first->getName();
    auto DataClassName = ClassName + "Data";
    auto DataSuperclassName = SuperclassName + "Data";
    llvm::SmallVector<std::string, 10> CursorNames;

    OS << "class " << DataClassName << ": " << DataSuperclassName
       << " {\n";

    // Caches for variables
    for (auto Child : getChildrenOf(Node)) {
      auto ChildName = getCursorName(Child);
      CursorNames.emplace_back(ChildName);
      auto ChildClassName = getCursorName(Child, /*VariableName=*/false);
      OS << "  private var _" << ChildName << "Cache = AtomicCache<"
         << ChildClassName << "SyntaxData>()\n";
      OS << "  var " << ChildName << ": " << ChildClassName << "SyntaxData {\n"
         << "    return _" << ChildName << "Cache.value {\n"
         << "      realizeChild(Cursor." << ChildName << ")\n"
         << "    }\n"
         << "  }\n\n";
    }

    // required initializer
    OS << "  override required init(raw: RawSyntaxProtocol, indexInParent: Int, parent: SyntaxData?) {\n"
          "    super.init(raw: raw, indexInParent: indexInParent, parent: parent)\n"
          "    precondition(raw.kind == ." << KindEnumCase << ")\n"
          "    precondition(raw.layout.count == " << getChildrenOf(Node).size() << ")\n";
    for (auto Child : getChildrenOf(Node)) {
      auto ChildName = getCursorName(Child);
      auto ChildType = getLayoutNodeRecord(Child);
      auto ChildVariable = "raw[Cursor." + ChildName + "]";
      if (isToken(ChildType)) {
        printTokenAssertion(ChildVariable, ChildType);
      } else {
        printSyntaxAssertion(ChildVariable, Child);
      }
    }
    OS << "  }\n\n";
    
    // Define "blank" constructor -- a version of this Data node with missing
    // raw syntax nodes for all children.
    OS << "  override class func blank() -> " << DataClassName << " {\n"
          "    let raw = RawSyntax(kind: ." << sanitized(Kind) << ",\n"
          "                        layout: [\n";
    for (const auto &Child : getChildrenOf(Node)) {
      auto ChildType = getLayoutNodeRecord(Child);
      auto ChildName = getCursorName(Child);
      if (isToken(ChildType)) {
        auto ChildRec = getLayoutNodeRecord(Child);
        auto TokenKind = ChildRec.getValueAsString("Kind");
        auto TokenSpelling = ChildRec.getValueAsString("Spelling");
        OS << "                          RawTokenSyntax.missing(." << sanitized(TokenKind) << ", text: \"" << TokenSpelling << "\"),\n";
      } else {
        OS << "                          RawSyntax.missing(." << ChildName << "),\n";
      }
    }
    OS << "                        ],\n"
          "                        presence: .present)\n"
          "    return " << DataClassName << "(raw: raw, indexInParent: 0, parent: nil)\n"
          "  }\n\n";
    
    if (!CursorNames.empty()) {
      // Define a "cursor" that we can use to "safely" access the children
      // of this data class.
      OS << "  enum Cursor: Int {\n";
      for (const auto &Cursor : CursorNames) {
        OS << "    case " << Cursor << "\n";
      }
      OS << "  }\n";
    }

    OS << "}\n\n";

    return false;
  }

  ~SwiftSyntaxGenerator() {}
};

#pragma mark - C++ Generator

class CPlusPlusSyntaxGenerator: public SyntaxImplementationGenerator {
  struct Namespaces {
    raw_ostream &OS;
    CPlusPlusSyntaxGenerator &Gen;
    Namespaces(raw_ostream &OS, CPlusPlusSyntaxGenerator &Gen):
      OS(OS), Gen(Gen) {
      OS << "namespace swift {\n";
      OS << "namespace syntax {\n";
      Gen.printForwardDeclarationsOfInterface();
    }

    ~Namespaces() {
      OS << "} // end namespace syntax\n";
      OS << "} // end namespace swift\n";
    }
  };

  struct HeaderGuard {
    raw_ostream &OS;
    HeaderGuard(raw_ostream &OS) : OS(OS) {
      OS << "#ifndef " << getHeaderGuard() << "\n";
      OS << "#define " << getHeaderGuard() << "\n\n";
    }

    ~HeaderGuard() {
      OS << "#endif // " << getHeaderGuard() << "\n";
    }
  };

public:

  CPlusPlusSyntaxGenerator(raw_ostream &OS):
    SyntaxImplementationGenerator(OS, TargetLanguage::CPlusPlus) {}

  virtual void printIncludesOfImplementation() {
    assert(options::Action == ActionType::GenImplementation);

    OS <<
      "#include \"swift/Syntax/RawSyntax.h\"\n"
      "#include \"swift/Syntax/SyntaxFactory.h\"\n"
      "#include \"swift/Syntax/Syntax.h\"\n"
      "#include \"swift/Syntax/SyntaxData.h\"\n"
      "#include \"swift/Syntax/CommonSyntax.h\"\n"
      "#include \"swift/Syntax/" << options::Category;
    OS << ".h\"\n";

    std::set<const Record *> ReferencedCategories;
    for (const auto *ReferencedRec :
           getRecordsReferencedByCategory(options::Category)) {
      if (isBaseSyntaxClass(*ReferencedRec)) {
        ReferencedCategories.insert(ReferencedRec);
      } else if (const auto *Base = getBaseSyntaxCategory(*ReferencedRec)) {
        ReferencedCategories.insert(Base);
      }
    }
    for (const auto *ReferencedCategory : ReferencedCategories) {
      OS << "#include \"swift/Syntax/" << ReferencedCategory->getName()
         << ".h\"\n";
    }

    OS <<
      "using namespace swift;\n"
      "using namespace swift::syntax;\n"
      "using llvm::None;\n"
      "using llvm::Optional;\n\n";
  }

  static std::string getHeaderGuard() {
    SmallString<64> GuardScratch;
    raw_svector_ostream OS(GuardScratch);

    OS << "SWIFT_SYNTAX_" << StringRef(options::Category).upper();
    OS << "_H";
    return OS.str();
  }

  virtual void printIncludesOfInterface() {
    OS <<
      "#include \"swift/Syntax/References.h\"\n"
      "#include \"swift/Syntax/SyntaxData.h\"\n"
      "#include \"swift/Syntax/Syntax.h\"\n"
      "#include \"swift/Syntax/SyntaxCollection.h\"\n"
      "#include \"swift/Syntax/TokenSyntax.h\"\n\n";
  }

  virtual void printForwardDeclarationsOfInterface() {
    if (categoryIsInSyntaxHierarchy()) {
      OS << "\n";
      auto Categories = SyntaxCategories;
      Categories.erase(getGeneratingCategoryRecord());

      // Add the common categories.
      for (const auto &NameAndRec : AllRecords->getDefs()) {
        const auto *Rec = NameAndRec.second.get();
        if (Rec->isAnonymous()) {
          continue;
        }

        if (auto CategoryField = Rec->getValue("Category")) {
          auto CategoryName = CategoryField->getValue()->getAsUnquotedString();
          if (CategoryName == "CommonSyntax") {
            Categories.insert(Rec);
          }
        }
      }

      auto ReferencedRecords =
        getRecordsReferencedByCategory(options::Category);
      for (const auto *ReferencedRec : ReferencedRecords) {
        // Types defined in this category's header file don't need to be
        // forward-declared, they're already in the header!
        if (auto CategoryField = ReferencedRec->getValue("Category")) {
          auto CategoryName = CategoryField->getValue()->getAsUnquotedString();
          if (CategoryName == options::Category) {
            continue;
          }
        }

        // Syntax and SyntaxData always come in through headers.
        if (ReferencedRec->getName() == "Syntax" ||
            ReferencedRec->getName() == "SyntaxData") {
          continue;
        }

        // TokenSyntax comes in through headers.
        if (ReferencedRec->getName() == "TokenSyntax" ||
            ReferencedRec->getName() == "TokenSyntaxData") {
          continue;
        }

        OS << "class " << ReferencedRec->getName() << ";\n";
        OS << "class " << ReferencedRec->getName() << "Data;\n";
      }
      OS << "\n";
    }
  }

  virtual void printTokenAssertion(std::string VariableName,
                                  const Record &TokenRec) {
    assert(isToken(TokenRec));
    auto Kind = TokenRec.getValueAsString("Kind");
    if (canBeAnyOfSyntaxCategory(TokenRec)) {
      OS << "  assert(" << VariableName << "->isToken());\n";
    } else {
      if (isIdentifier(TokenRec)) {
        OS << "  assert(cast<RawTokenSyntax>(" << VariableName
           << ")->getTokenKind() == tok::" << Kind << ");\n";
      } else {
        OS << "  syntax_assert_token_is(cast<RawTokenSyntax>(" << VariableName
           << "), tok::" << Kind << ", \"" << getTokenSpelling(TokenRec)
           << "\");\n";
      }
    }
  }

  virtual void printSyntaxAssertion(Twine ChildVariable,
                            const RecordVal Child) {
    auto NodeType = getLayoutNodeRecord(Child);
    auto NodeTypeName = NodeType.getName();
    auto NodeKind = stripSyntaxSuffix(NodeTypeName);
    if (canBeAnyOfSyntaxCategory(NodeType)) {
      auto &Category = getSyntaxCategory(NodeType);
      OS << "  assert(" << ChildVariable << "->is"
         << Category.getName() << "());\n";
    } else {
      OS << "  assert(" << ChildVariable << "->getKind() == SyntaxKind::"
         << NodeKind << ");\n";
    }
  }

  virtual bool printSyntaxInterfaces() {
    HeaderGuard HG { OS };
    printIncludesOfInterface();
    Namespaces NS { OS, *this };

    SyntaxImplementationGenerator::printSyntaxInterfaces();
    
    return false;
  }

  virtual bool printSyntaxInterface(const Record &Node) {
    auto ClassName = Node.getName().str();
    auto Kind = stripSyntaxSuffix(ClassName).str();
    llvm::errs() << ClassName << "supers:\n";
    for (const auto &Super : Node.getSuperClasses()) {
      llvm::errs() << Super.first->getName() << "\n";
    }
    auto SuperclassName = Node.getSuperClasses().back().first->getName().str();
    auto DataClassName = ClassName + "Data";

    auto Superclass = SuperclassName;

    if (SuperclassName == "SyntaxCollection") {
      auto ElementChild = cast<DefInit>(Node.getValue("Element")->getValue());
      auto TemplateArgs = std::string("<SyntaxKind::") + Kind + ", "
                        + ElementChild->getDef()->getName().str()
                        + std::string(">");
      Superclass += TemplateArgs;
    }

    OS << "class " << ClassName << " : public " << Superclass << " {\n"
    "  friend struct SyntaxFactory;\n"
    "  friend class " << DataClassName << ";\n"
    "  friend class Syntax;\n"
    "  friend class SyntaxData;\n"
    "\n";

    if (isBaseSyntaxClass(Node)) {
      OS << "public:\n";
    }
    OS <<
    "  using DataType = " << DataClassName << ";\n"
    "\n";

    if (!getChildrenOf(Node).empty()) {
      OS << "  enum class Cursor : CursorIndex {\n";
      for (const auto &Child : getChildrenOf(Node)) {
        OS << "    " << Child.getName() << ",\n";
      }
      OS << "  };\n";
    }

    OS <<
    "  " << ClassName << "(RC<SyntaxData> Root, const DataType* Data)\n"
    "    : " << SuperclassName << "(Root, Data) {}\n"
    "public:\n";
    for (const auto &Child : getChildrenOf(Node)) {
      auto ChildType = getLayoutNodeRecord(Child);
      auto ChildTypeName = getChildTypeName(ChildType);
      OS << "  " << ChildTypeName << " get" << Child.getName() << "() const;\n";
      OS << "  " << ClassName << " with" << Child.getName() << "("
         << ChildTypeName << " New" << Child.getName() << ") const;\n\n";
    }
    OS << "  static bool classof(const Syntax *S) {\n";
    if (isBaseSyntaxClass(Node)) {
      OS << "    return S->is" << Kind << "();\n";
    } else {
      OS << "    return S->getKind() == SyntaxKind::" << Kind << ";\n";
    }
    
    OS <<
    "  }\n"
    "};\n\n";
    
    return false;
  }

  virtual bool printSyntaxImplementation(const Record &Node) {
    auto ClassName = Node.getName();

    for (auto Child : getChildrenOf(Node)) {
      auto ChildName = Child.getName();
      auto ChildType = getLayoutNodeRecord(Child);
      auto ChildTypeName = getChildTypeName(ChildType);

      // Getter
      OS << ChildTypeName << "\n" <<
      ClassName << "::get" << ChildName << "() const {\n"
      "  auto RawChild = getRaw()->getChild(Cursor::" << ChildName << ");\n"
      "  auto *MyData = getUnsafeData<" << ClassName << ">();\n"
      "  auto &ChildPtr = *reinterpret_cast<std::atomic<uintptr_t>*>(\n"
      "    &MyData->Cached" << ChildName << ");\n"
      "  SyntaxData::realizeSyntaxNode<" << ChildTypeName << ">(ChildPtr, RawChild, MyData, cursorIndex(Cursor::" << ChildName << "));\n"
      "  return " << ChildTypeName << " { Root, MyData->Cached" << ChildName << ".get() };\n"
      "}\n\n";

      // Setter
      auto NewChildParam = "New" + ChildName;
      OS << ClassName << "\n" << ClassName << "::with" << ChildName << "(" << ChildTypeName << " " << NewChildParam << ") const {\n";

      auto RawNewChild = NewChildParam + ".getRaw()";
      if (isToken(ChildType)) {
        printTokenAssertion(RawNewChild.str(), ChildType);
      }
      OS << "  return Data->replaceChild<" << ClassName << ">(" << RawNewChild << ", " << "Cursor::" << ChildName << ");\n";
      OS << "}\n\n";
    }

    return false;
  }

  virtual bool printSyntaxDataInterface(const Record &Node) {
    auto ClassName = Node.getName();
    auto SuperclassName = Node.getSuperClasses().back().first->getName();
    auto Kind = stripSyntaxSuffix(ClassName).str();
    auto DataClassName = ClassName + "Data";
    auto DataSuperclassName = SuperclassName + "Data";

    if (SuperclassName == "SyntaxCollection") {
      auto ElementChild = cast<DefInit>(Node.getValue("Element")->getValue());
      auto TemplateArgs = std::string("<SyntaxKind::") + Kind + ", " + ElementChild->getDef()->getName().str() + std::string(">");
      OS << "using " << DataClassName << " = " << DataSuperclassName << TemplateArgs << ";\n\n";
      return false;
    }

    OS << "class " << DataClassName << " : public " << DataSuperclassName << " {\n"
    "  friend class SyntaxData;\n"
    "  friend struct SyntaxFactory;\n"
    "  friend class " << ClassName << ";\n\n";

    // Private, cached RC<*SyntaxData> members
    for (const auto &Child : getChildrenOf(Node)) {
      auto ChildType = getLayoutNodeRecord(Child);
      auto ChildTypeName = getChildTypeName(ChildType) + "Data";
      OS << "  RC<" << ChildTypeName << "> Cached" << Child.getName() << ";\n";
    }

    if (isBaseSyntaxClass(Node)) {
      OS << "protected:\n";
    }

    OS <<
    "\n"
    "  " << DataClassName << "(RC<RawSyntax> Raw, const SyntaxData *Parent = nullptr, CursorIndex IndexInParent = 0);\n"
    "\n"
    "  static RC<" << DataClassName << "> make(RC<RawSyntax> Raw, const SyntaxData *Parent = nullptr, CursorIndex IndexInParent = 0);\n"
    "  static RC<" << DataClassName << "> makeBlank();\n"
    "\n"
    "public:\n"
    "  static bool classof(const SyntaxData *SD) {\n";
    if (isBaseSyntaxClass(Node)) {
      OS << "    return SD->is" << Kind << "();\n";
    } else {
      OS << "    return SD->getKind() == SyntaxKind::" << Kind << ";\n";
    }
    
    OS <<
    "  }\n"
    "};\n\n";
    return false;
  }

  virtual bool printSyntaxDataImplementation(const Record &Node) {
    auto ClassName = Node.getName();
    auto Kind = stripSyntaxSuffix(ClassName);
    auto SuperclassName = Node.getSuperClasses().back().first->getName();
    auto DataClassName = ClassName + "Data";
    auto DataSuperclassName = SuperclassName + "Data";

    // Constructor
    OS << DataClassName << "::" << DataClassName
       << "(RC<RawSyntax> Raw, const SyntaxData *Data, "
          "const CursorIndex IndexInParent)\n"
    "  : " << DataSuperclassName << "(Raw, Data, IndexInParent) {\n"
    "  assert(Raw->Kind == SyntaxKind::" << Kind << ");\n"
    "  assert(Raw->Layout.size() == " << getChildrenOf(Node).size() << ");\n";
    for (const auto &Child : getChildrenOf(Node)) {
      auto ChildName = Child.getName();
      auto ChildType = getLayoutNodeRecord(Child);
      auto ChildVariable = "Raw->getChild(" + ClassName + "::Cursor::" +
                           ChildName + ")";
      if (isToken(ChildType)) {
        printTokenAssertion(ChildVariable.str(), ChildType);
      } else {
        printSyntaxAssertion(ChildVariable, Child);
      }
    }
    OS << "}\n\n";

    // make
    OS << "RC<" << DataClassName << ">\n" <<
    DataClassName << "::make(RC<RawSyntax> Raw, const SyntaxData *Parent, "
                     "const CursorIndex IndexInParent) {\n"
    "  return RC<" << DataClassName << "> {\n"
    "    new " << DataClassName << " { Raw, Parent, IndexInParent }\n"
    "  };\n"
    "}\n\n";

    // makeBlank
    OS << "RC<" << DataClassName << ">\n" <<
    DataClassName << "::makeBlank() {\n"
    "  return make(RawSyntax::make(SyntaxKind::" << Kind << ",\n"
    "  {\n";
    for (const auto &Child : getChildrenOf(Node)) {
      auto ChildType = getLayoutNodeRecord(Child);
      if (isToken(ChildType)) {
        auto ChildRec = getLayoutNodeRecord(Child);
        auto TokenKind = ChildRec.getValueAsString("Kind");
        auto TokenSpelling = ChildRec.getValueAsString("Spelling");
        OS << "    RawTokenSyntax::missingToken(tok::" << TokenKind << ", \"" <<
              TokenSpelling << "\"),\n";
      } else {
        auto ChildKind = getMissingSyntaxKind(Child);
        OS << "    RawSyntax::missing(SyntaxKind::" << ChildKind << "),\n";
      }
    }
    OS << "  },\n"
    "  SourcePresence::Present));\n"
    "}\n\n";
    
    return false;
  }

  virtual bool printSyntaxFactoryInterface() {
    HeaderGuard HG { OS };
    Namespaces NS { OS, *this };
    // TODO
    return false;
  }


  virtual bool printSyntaxFactoryImplementation() {
    // TODO
    return false;
  }

  virtual bool printSyntaxRewriterInterface() {
    HeaderGuard HG { OS };
    Namespaces NS { OS, *this };
    // TODO
    return false;
  }

  virtual bool printSyntaxRewriterImplementation() {
    // TODO
    return false;
  }

  ~CPlusPlusSyntaxGenerator() {}
};

static bool SyntaxTableGenMain(raw_ostream &OS, RecordKeeper &Records) {
  AllRecords = &Records;
  SyntaxCategories.insert(AllRecords->getClass("Syntax"));
  SyntaxCategories.insert(AllRecords->getClass("DeclSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("StmtSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("ExprSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("TypeSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("PatternSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("TokenSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("SyntaxCollection"));

  std::unique_ptr<SyntaxImplementationGenerator> Gen;

  switch (options::Language) {
  case TargetLanguage::Swift:
    Gen = make_unique<SwiftSyntaxGenerator>(OS);
    break;
  case TargetLanguage::CPlusPlus:
    Gen = make_unique<CPlusPlusSyntaxGenerator>(OS);
    break;
  }

  switch (options::Action) {
    case ActionType::None:
      llvm::errs() << "action required\n";
      llvm::cl::PrintHelpMessage();
      return true;
    case ActionType::GenInterface:
      return Gen->genInterface();
    case ActionType::GenImplementation:
      return Gen->genImplementation();
  }
}

enum EnumGenerateFlags: uint8_t {
  Base = 0,
  Text = 1 << 0,
  Equals = 1 << 1
};

std::string escaped(StringRef str) {
  if (str == "\\") {
    return "\\\\";
  }
  return str;
}

void printSwiftEnum(raw_ostream &os, StringRef name,
                    uint8_t Flags,
                    ArrayRef<StringRef> vals,
                    ArrayRef<StringRef> stringContaining = {},
                    ArrayRef<StringRef> texts = {}) {
  os << "public enum " << name.str() << " {\n";
  for (auto name : stringContaining) {
    os << "  case " << name << "(String)\n";
  }
  for (auto name : vals) {
    os << "  case " << name << "\n";
  }
  if (Flags & EnumGenerateFlags::Text) {
    os << "\n  var text: String {\n"
          "    switch self {\n";
    for (auto name : stringContaining) {
      os << "    case ." << name << "(let text): return text\n";
    }
    for (size_t i = 0; i < texts.size(); i += 1) {
      auto text = escaped(texts[i]);
      os << "    case ." << vals[i] << ": return \"" << text << "\"\n";
    }
    os << "    }\n"
          "  }\n";
  }
  os << "}\n\n";

  if (Flags & EnumGenerateFlags::Equals) {
    os << "extension " << name.str() << ": Equatable {\n"
          "  public static func ==(lhs: " << name.str() << ", rhs: " << name.str()
       << ") -> Bool {\n"
          "    switch (lhs, rhs) {\n";
    for (auto name : vals) {
      os << "    case (." << name << ", ." << name << "): return true\n";
    }
    for (auto name : stringContaining) {
      os << "    case let (." << name << "(lhsText), ." << name
         << "(rhsText)): return lhsText == rhsText\n";
    }
    os << "    default: return false\n"
          "    }\n"
          "  }\n"
          "}\n\n";
  }
}

int main(int argc, char **argv) {
  /*
  printSwiftEnum(llvm::outs(), "TokenKind",
                 EnumGenerateFlags::Text | EnumGenerateFlags::Equals,
  {
    "eof",
#define KEYWORD(Id) #Id "Keyword",
#define PUNCTUATOR(Id, Text) #Id,
#define POUND_KEYWORD(Id) "pound" #Id,
#define POUND_OLD_OBJECT_LITERAL(Id, A, B, C) // Ignoring old object literal syntax
#define SIL_KEYWORD(Id) // Ignoring SIL keyword
#define SIL_PUNCTUATOR(Id, Text) // Ignoring SIL punctuator
#include "swift/Syntax/TokenKinds.def"
  },
  {
   "identifier",
   "integerLiteral",
   "floatingLiteral",
   "unspacedBinaryOperator",
   "spacedBinaryOperator",
   "postfixOperator",
   "prefixOperator",
   "dollarIdentifier",
   "stringLiteral",
   "comment",
  },
  {
    "eof",
#define KEYWORD(Id) #Id,
#define PUNCTUATOR(Id, Text) Text,
#define POUND_KEYWORD(Id) #Id,
#define POUND_OLD_OBJECT_LITERAL(Id, A, B, C) // Ignoring old object literal syntax
#define SIL_KEYWORD(Id) // Ignoring SIL keyword
#define SIL_PUNCTUATOR(Id, Text) // Ignoring SIL punctuator
#include "swift/Syntax/TokenKinds.def"
  });
  printSwiftEnum(llvm::outs(), "SyntaxKind", EnumGenerateFlags::Base, {
    "Token",
    "Unknown",
#define SYNTAX(Id, Parent) #Id,
#define SYNTAX_COLLECTION(Id, Element) #Id,
#define MISSING_SYNTAX(Id, Parent) #Id,
#include "swift/Syntax/SyntaxKinds.def"
   });
   */
  sys::PrintStackTraceOnErrorSignal(argv[0]);
  cl::ParseCommandLineOptions(argc, argv);
  if (getCategory() == Category::Unknown) {
    errs() << options::Category << " is an unknown category!\n";
    cl::PrintHelpMessage();
    return 1;
  }
  return TableGenMain(argv[0], &SyntaxTableGenMain);
}
