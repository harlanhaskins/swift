#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/ADT/StringSwitch.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/Signals.h"
#include "llvm/TableGen/Error.h"
#include "llvm/TableGen/Main.h"
#include "llvm/TableGen/Record.h"

using namespace llvm;

enum class ActionType {
  None,
  GenImplementation,
  GenInterface,
};

enum class Category {
  Unknown,
  DeclSyntax,
  ExprSyntax,
  StmtSyntax,
  TypeSyntax,
  PatternSyntax,
  GenericSyntax,
  AttributeSyntax,
  CommonSyntax,
  SyntaxFactory,
  SyntaxRewriter,
};

enum class TargetLanguage {
  CPlusPlus,
};

RecordKeeper *AllRecords;
SmallSet<const Record *, 8> SyntaxCategories;

namespace options {
static cl::opt<ActionType> Action(
  cl::desc("Action to perform: "),
  cl::init(ActionType::None),
  cl::values(
    clEnumValN(ActionType::GenImplementation, "implementation",
      "Generate the implementation for the given syntax category"),
    clEnumValN(ActionType::GenInterface, "interface",
      "Generate the interface for the given syntax category")
    )
);
static cl::opt<TargetLanguage> Language(
  "language",
  cl::desc("Target language to emit: "),
  cl::init(TargetLanguage::CPlusPlus),
  cl::values(
    clEnumValN(TargetLanguage::CPlusPlus, "c++",
      "Generate the interface or implementation in C++")
  )
);
static cl::opt<std::string> Category(
  "category",
  cl::desc("Category to emit"));

} // end options namespace

#pragma mark - Helpers

static void printAutogenReminder(raw_ostream &OS) {
  OS << "/// This file autogenerated by swift-syntax-tblgen - DO NOT EDIT!\n";
  OS << "\n";
}

/// Returns true if the record type is a subclass of Syntax.
/// Used to filter out values in a record that tablegen automatically inserts, like NAME,
/// or auxiliary fields that we have added, like IsRequired.
static bool is(const Record &Rec, StringRef TypeName) {
  if (Rec.getName() == TypeName || Rec.isSubClassOf(AllRecords->getClass(TypeName))) {
    return true;
  }
  return false;
}

static bool isBaseSyntaxClass(const Record &Node) {
  return llvm::StringSwitch<bool>(Node.getName())
  .Case("DeclSyntax", true)
  .Case("ExprSyntax", true)
  .Case("StmtSyntax", true)
  .Case("TypeSyntax", true)
  .Case("PatternSyntax", true)
  .Default(false);
}

static bool isToken(const Record &Rec) {
  return is(Rec, "TokenSyntax");
}

static bool isIdentifier(const Record &Rec) {
  return is(Rec, "Identifier");
}

static bool isLayout(const Record &Rec) {
  return is(Rec, "Layout");
}

/// For a given child value of Layout<T>, return the record for T, which
/// represents a concrete definition of a syntax node.
static const Record *getChildRecord(const RecordVal Child) {
  if (const auto *DI = dyn_cast<DefInit>(Child.getValue())) {
    return DI->getDef();
  }
  return nullptr;
}

static const Record *getGeneratingCategoryRecord() {
  return AllRecords->getDef(options::Category);
}

static const Record &getTokenSyntaxRecord() {
  return *AllRecords->getClass("TokenSyntax")->getDefInit()->getDef();
}

bool canBeAnyOfSyntaxCategory(const Record &Rec) {
  return Rec.getName().startswith("Any");
}

/// For a given child record of Layout<T>, return the record for T, which
/// represents a concrete definition of a syntax node.
static const Record &getLayoutNodeRecord(const Record &Rec) {
  assert(isLayout(Rec));
  const auto NodeField = *Rec.getValue("Node");
  return *getChildRecord(NodeField);
}

static const Record &getLayoutNodeRecord(const RecordVal Child) {
  return getLayoutNodeRecord(*getChildRecord(Child));
}

static const Record *getBaseSyntaxCategory(const Record &Child) {
  for (const auto Super : Child.getSuperClasses()) {
    if (isBaseSyntaxClass(*Super.first)) {
      return Super.first;
    }
  }
  return nullptr;
}

static const StringRef getChildTypeName(const Record &Rec) {
  if (isToken(Rec)) {
    return "TokenSyntax";
  }
  if (canBeAnyOfSyntaxCategory(Rec)) {
    if (auto BaseCategory = getBaseSyntaxCategory(Rec)) {
      return BaseCategory->getName();
    }
  }
  return Rec.getName();
}

static const Record &
getSyntaxCategory(const Record &Def) {
  for (const auto Super : Def.getSuperClasses()) {
    if (SyntaxCategories.count(Super.first)) {
      return *Super.first;
    }
  }
  llvm_unreachable("Record didn't have a syntax category??");
}

static StringRef getTokenSpelling(const Record &TokenRec) {
  assert(isToken(TokenRec));
  for (const auto Field : TokenRec.getValues()) {
    if (Field.getName() == "Spelling") {
      return Field.getValue()->getAsUnquotedString();
    }
  }
  return StringRef();
}

static StringRef stripSyntaxSuffix(StringRef TypeName) {
  auto Pos = TypeName.rfind("Syntax");
  if (Pos == StringRef::npos) {
    return TypeName;
  }
  return TypeName.slice(0, Pos);
}

static std::string getMissingSyntaxKind(const RecordVal Child) {
  // TODO
  return "Missing";
}

static Category getCategory() {
  return llvm::StringSwitch<Category>(options::Category)
  .Case("DeclSyntax", Category::DeclSyntax)
  .Case("ExprSyntax", Category::ExprSyntax)
  .Case("StmtSyntax", Category::StmtSyntax)
  .Case("TypeSyntax", Category::TypeSyntax)
  .Case("PatternSyntax", Category::PatternSyntax)
  .Case("GenericSyntax", Category::GenericSyntax)
  .Case("AttributeSyntax", Category::AttributeSyntax)
  .Case("CommonSyntax", Category::CommonSyntax)
  .Case("SyntaxFactory", Category::SyntaxFactory)
  .Case("SyntaxRewriter", Category::SyntaxRewriter)
  .Default(Category::Unknown);
}

static bool categoryHasBaseClass() {
  switch (getCategory()) {
    case Category::DeclSyntax:
    case Category::ExprSyntax:
    case Category::PatternSyntax:
    case Category::StmtSyntax:
    case Category::TypeSyntax:
      return true;
    default:
      return false;
  }
}

static bool categoryIsInSyntaxHierarchy() {
  switch (getCategory()) {
  case Category::DeclSyntax:
  case Category::ExprSyntax:
  case Category::PatternSyntax:
  case Category::StmtSyntax:
  case Category::TypeSyntax:
  case Category::GenericSyntax:
  case Category::AttributeSyntax:
  case Category::CommonSyntax:
    return true;
  default:
    return false;
  }
}

static std::vector<RecordVal> getChildrenOf(const Record &Node) {
  std::vector<RecordVal> Children;

  for (const auto Child : Node.getValues()) {
    if (auto ChildRec = getChildRecord(Child)) {
      if (!isLayout(*ChildRec)) {
        continue;
      }
      Children.push_back(Child);
    }
  }

  return Children;
}

/// Returns the records for a category that we should print code for.
static std::vector<const Record *>
getRecordsForCategory(const std::string &Category) {
  std::vector<const Record *> Records;
  for (const auto &NameAndRec : AllRecords->getDefs()) {
    if (NameAndRec.second->getName().startswith("Any")) {
      continue;
    }
    if (NameAndRec.second->isAnonymous()) {
      continue;
    }
    if (NameAndRec.second->getValueAsString("Category") != options::Category) {
      continue;
    }
    Records.push_back(NameAndRec.second.get());
  }
  return Records;
}

/// Returns the records referenced by this category's records, used
/// for printing forward declarations, for example.
static std::set<const Record *>
getRecordsReferencedByCategory(const std::string &Category) {
  std::set<const Record *> ReferencedRecords;
  auto Nodes = getRecordsForCategory(Category);
  for (const auto *Node : Nodes) {
    for (const auto Child : getChildrenOf(*Node)) {
      const auto &ChildType = getLayoutNodeRecord(Child);
      if (isToken(ChildType)) {
        continue;
      }
      if (canBeAnyOfSyntaxCategory(ChildType)) {
        if (const auto *Base = getBaseSyntaxCategory(ChildType)) {
          ReferencedRecords.insert(Base);
          continue;
        }
      }
      if (std::find(Nodes.begin(), Nodes.end(), &ChildType) == Nodes.end()) {
        ReferencedRecords.insert(&ChildType);
      }
    }
  }
  return ReferencedRecords;
}

static void printTokenAssertion(std::string VariableName,
                                const Record &TokenRec,
                                raw_ostream &OS) {
  assert(isToken(TokenRec));
  auto Kind = TokenRec.getValueAsString("Kind");
  if (canBeAnyOfSyntaxCategory(TokenRec)) {
    OS << "  assert(" << VariableName << "->isToken());\n";
  } else {
    if (isIdentifier(TokenRec)) {
      OS << "  assert(cast<RawTokenSyntax>(" << VariableName << ")->getTokenKind() == tok::" << Kind << ");\n";
    } else {
      OS << "  syntax_assert_token_is(cast<RawTokenSyntax>(" << VariableName << "), tok::" << Kind << ", \"" << getTokenSpelling(TokenRec) << "\");\n";
    }
  }
}

static void printSyntaxAssertion(Twine ChildVariable,
                                 const RecordVal Child,
                                 raw_ostream &OS) {
  auto NodeType = getLayoutNodeRecord(Child);
  auto NodeTypeName = NodeType.getName();
  auto NodeKind = stripSyntaxSuffix(NodeTypeName);
  if (canBeAnyOfSyntaxCategory(NodeType)) {
    auto &Category = getSyntaxCategory(NodeType);
    OS << "  assert(" << ChildVariable << "->is" << Category.getName() << "());\n";
  } else {
    OS << "  assert(" << ChildVariable << "->getKind() == SyntaxKind::" << NodeKind << ");\n";
  }
}

static void printIncludesOfImplementation(raw_ostream &OS) {
  assert(options::Action == ActionType::GenImplementation);

  OS <<
  "#include \"swift/Syntax/RawSyntax.h\"\n"
  "#include \"swift/Syntax/SyntaxFactory.h\"\n"
  "#include \"swift/Syntax/Syntax.h\"\n"
  "#include \"swift/Syntax/SyntaxData.h\"\n"
  "#include \"swift/Syntax/CommonSyntax.h\"\n"
  "#include \"swift/Syntax/" << options::Category;
  OS << ".h\"\n";

  std::set<const Record *> ReferencedCategories;
  for (const auto *ReferencedRec : getRecordsReferencedByCategory(options::Category)) {
    if (isBaseSyntaxClass(*ReferencedRec)) {
      ReferencedCategories.insert(ReferencedRec);
    } else if (const auto *Base = getBaseSyntaxCategory(*ReferencedRec)) {
      ReferencedCategories.insert(Base);
    }
  }
  for (const auto *ReferencedCategory : ReferencedCategories) {
    OS << "#include \"swift/Syntax/" << ReferencedCategory->getName() << ".h\"\n";
  }

  OS <<
  "using namespace swift;\n"
  "using namespace swift::syntax;\n"
  "using llvm::None;\n"
  "using llvm::Optional;\n\n";
}

static std::string getHeaderGuard() {
  SmallString<64> GuardScratch;
  raw_svector_ostream OS(GuardScratch);

  OS << "SWIFT_SYNTAX_" << StringRef(options::Category).upper();
  OS << "_H";
  return OS.str();
}

struct HeaderGuard {
  raw_ostream &OS;
  HeaderGuard(raw_ostream &OS) : OS(OS) {
    OS << "#ifndef " << getHeaderGuard() << "\n";
    OS << "#define " << getHeaderGuard() << "\n\n";
  }

  ~HeaderGuard() {
    OS << "#endif // " << getHeaderGuard() << "\n";
  }
};

static void printIncludesOfInterface(raw_ostream &OS) {
  OS <<
  "#include \"swift/Syntax/References.h\"\n"
  "#include \"swift/Syntax/SyntaxData.h\"\n"
  "#include \"swift/Syntax/Syntax.h\"\n"
  "#include \"swift/Syntax/SyntaxCollection.h\"\n"
  "#include \"swift/Syntax/TokenSyntax.h\"\n\n";
}

static void printForwardDeclarationsOfInterface(raw_ostream &OS) {
  if (categoryIsInSyntaxHierarchy()) {
    OS << "\n";
    auto Categories = SyntaxCategories;
    Categories.erase(getGeneratingCategoryRecord());

    // Add the common categories.
    for (const auto &NameAndRec : AllRecords->getDefs()) {
      const auto *Rec = NameAndRec.second.get();
      if (Rec->isAnonymous()) {
        continue;
      }

      if (auto CategoryField = Rec->getValue("Category")) {
        auto CategoryName = CategoryField->getValue()->getAsUnquotedString();
        if (CategoryName == "CommonSyntax") {
          Categories.insert(Rec);
        }
      }
    }

    auto ReferencedRecords = getRecordsReferencedByCategory(options::Category);
    for (const auto *ReferencedRec : ReferencedRecords) {
      // Types defined in this category's header file don't need to be
      // forward-declared, they're already in the header!
      if (auto CategoryField = ReferencedRec->getValue("Category")) {
        auto CategoryName = CategoryField->getValue()->getAsUnquotedString();
        if (CategoryName == options::Category) {
          continue;
        }
      }

      // Syntax and SyntaxData always come in through headers.
      if (ReferencedRec->getName() == "Syntax" ||
          ReferencedRec->getName() == "SyntaxData") {
        continue;
      }

      // TokenSyntax comes in through headers.
      if (ReferencedRec->getName() == "TokenSyntax" ||
          ReferencedRec->getName() == "TokenSyntaxData") {
        continue;
      }

      OS << "class " << ReferencedRec->getName() << ";\n";
      OS << "class " << ReferencedRec->getName() << "Data;\n";
    }
    OS << "\n";
  }
}


struct Namespaces {
  raw_ostream &OS;
  Namespaces(raw_ostream &OS) : OS(OS) {
    OS << "namespace swift {\n";
    OS << "namespace syntax {\n";
    printForwardDeclarationsOfInterface(OS);
  }

  ~Namespaces() {
    OS << "} // end namespace syntax\n";
    OS << "} // end namespace swift\n";
  }
};

#pragma mark - Syntax

static bool printSyntaxInterface(const Record &Node, raw_ostream &OS) {
  auto ClassName = Node.getName().str();
  auto Kind = stripSyntaxSuffix(ClassName).str();
  llvm::errs() << ClassName << "supers:\n";
  for (const auto Super : Node.getSuperClasses()) {
    llvm::errs() << Super.first->getName() << "\n";
  }
  auto SuperclassName = Node.getSuperClasses().back().first->getName().str();
  auto DataClassName = ClassName + "Data";

  auto Superclass = SuperclassName;

  if (SuperclassName == "SyntaxCollection") {
    auto ElementChild = cast<DefInit>(Node.getValue("Element")->getValue());
    auto TemplateArgs = std::string("<SyntaxKind::") + Kind + ", " + ElementChild->getDef()->getName().str() + std::string(">");
    Superclass += TemplateArgs;
  }

  OS << "class " << ClassName << " : public " << Superclass << " {\n"
  "  friend struct SyntaxFactory;\n"
  "  friend class " << DataClassName << ";\n"
  "  friend class Syntax;\n"
  "  friend class SyntaxData;\n"
  "\n";

  if (isBaseSyntaxClass(Node)) {
    OS << "public:\n";
  }
  OS <<
  "  using DataType = " << DataClassName << ";\n"
  "\n";

  if (!getChildrenOf(Node).empty()) {
    OS << "  enum class Cursor : CursorIndex {\n";
    for (const auto Child : getChildrenOf(Node)) {
      OS << "    " << Child.getName() << ",\n";
    }
    OS << "  };\n";
  }

  OS <<
  "  " << ClassName << "(RC<SyntaxData> Root, const DataType* Data)\n"
  "    : " << SuperclassName << "(Root, Data) {}\n"
  "public:\n";
  for (const auto Child : getChildrenOf(Node)) {
    auto ChildType = getLayoutNodeRecord(Child);
    auto ChildTypeName = getChildTypeName(ChildType);
    OS << "  " << ChildTypeName << " get" << Child.getName() << "() const;\n";
    OS << "  " << ClassName << " with" << Child.getName() << "(" << ChildTypeName << " New" << Child.getName() << ") const;\n\n";
  }
  OS << "  static bool classof(const Syntax *S) {\n";
  if (isBaseSyntaxClass(Node)) {
    OS << "    return S->is" << Kind << "();\n";
  } else {
    OS << "    return S->getKind() == SyntaxKind::" << Kind << ";\n";
  }

  OS <<
  "  }\n"
  "};\n\n";

  return false;
}

static bool printSyntaxDataInterface(const Record &Node, raw_ostream &OS) {
  auto ClassName = Node.getName();
  auto SuperclassName = Node.getSuperClasses().back().first->getName();
  auto Kind = stripSyntaxSuffix(ClassName).str();
  auto DataClassName = ClassName + "Data";
  auto DataSuperclassName = SuperclassName + "Data";

  if (SuperclassName == "SyntaxCollection") {
    auto ElementChild = cast<DefInit>(Node.getValue("Element")->getValue());
    auto TemplateArgs = std::string("<SyntaxKind::") + Kind + ", " + ElementChild->getDef()->getName().str() + std::string(">");
    OS << "using " << DataClassName << " = " << DataSuperclassName << TemplateArgs << ";\n\n";
    return false;
  }

  OS << "class " << DataClassName << " : public " << DataSuperclassName << " {\n"
  "  friend class SyntaxData;\n"
  "  friend struct SyntaxFactory;\n"
  "  friend class " << ClassName << ";\n\n";

  // Private, cached RC<*SyntaxData> members
  for (const auto Child : getChildrenOf(Node)) {
    auto ChildType = getLayoutNodeRecord(Child);
    auto ChildTypeName = getChildTypeName(ChildType) + "Data";
    OS << "  RC<" << ChildTypeName << "> Cached" << Child.getName() << ";\n";
  }

  if (isBaseSyntaxClass(Node)) {
    OS << "protected:\n";
  }

  OS <<
  "\n"
  "  " << DataClassName << "(RC<RawSyntax> Raw, const SyntaxData *Parent = nullptr, CursorIndex IndexInParent = 0);\n"
  "\n"
  "  static RC<" << DataClassName << "> make(RC<RawSyntax> Raw, const SyntaxData *Parent = nullptr, CursorIndex IndexInParent = 0);\n"
  "  static RC<" << DataClassName << "> makeBlank();\n"
  "\n"
  "public:\n"
  "  static bool classof(const SyntaxData *SD) {\n";
  if (isBaseSyntaxClass(Node)) {
    OS << "    return SD->is" << Kind << "();\n";
  } else {
    OS << "    return SD->getKind() == SyntaxKind::" << Kind << ";\n";
  }

  OS <<
  "  }\n"
  "};\n\n";
  return false;
}

static bool printSyntaxInterfaces(raw_ostream &OS) {
  HeaderGuard HG { OS };
  printIncludesOfInterface(OS);
  Namespaces NS { OS };

  // Print the interface of the "base" category classes, such as 'Stmt', 'Expr',
  // etc.
  if (categoryHasBaseClass()) {
    auto CategoryRecord = AllRecords->getClass(options::Category);
    printSyntaxDataInterface(*CategoryRecord, OS);
    printSyntaxInterface(*CategoryRecord, OS);
  }

  const auto Nodes = getRecordsForCategory(options::Category);
  for (const auto *Node : Nodes) {
    printSyntaxDataInterface(*Node, OS);
    printSyntaxInterface(*Node, OS);
  }

  return false;
}

static bool printSyntaxImplementation(const Record &Node, raw_ostream &OS) {
  auto ClassName = Node.getName();

  for (auto Child : getChildrenOf(Node)) {
    auto ChildName = Child.getName();
    auto ChildType = getLayoutNodeRecord(Child);
    auto ChildTypeName = getChildTypeName(ChildType);

    // Getter
    OS << ChildTypeName << "\n" <<
    ClassName << "::get" << ChildName << "() const {\n"
    "  auto RawChild = getRaw()->getChild(Cursor::" << ChildName << ");\n"
    "  auto *MyData = getUnsafeData<" << ClassName << ">();\n"
    "  auto &ChildPtr = *reinterpret_cast<std::atomic<uintptr_t>*>(\n"
    "    &MyData->Cached" << ChildName << ");\n"
    "  SyntaxData::realizeSyntaxNode<" << ChildTypeName << ">(ChildPtr, RawChild, MyData, cursorIndex(Cursor::" << ChildName << "));\n"
    "  return " << ChildTypeName << " { Root, MyData->Cached" << ChildName << ".get() };\n"
    "}\n\n";

    // Setter
    auto NewChildParam = "New" + ChildName;
    OS << ClassName << "\n" << ClassName << "::with" << ChildName << "(" << ChildTypeName << " " << NewChildParam << ") const {\n";

    auto RawNewChild = NewChildParam + ".getRaw()";
    if (isToken(ChildType)) {
      printTokenAssertion(RawNewChild.str(), ChildType, OS);
    }
    OS << "  return Data->replaceChild<" << ClassName << ">(" << RawNewChild << ", " << "Cursor::" << ChildName << ");\n";
    OS << "}\n\n";
  }

  return false;
}

static bool printSyntaxDataImplementation(const Record &Node, raw_ostream &OS) {
  auto ClassName = Node.getName();
  auto Kind = stripSyntaxSuffix(ClassName);
  auto SuperclassName = Node.getSuperClasses().back().first->getName();
  auto DataClassName = ClassName + "Data";
  auto DataSuperclassName = SuperclassName + "Data";

  // Constructor
  OS << DataClassName << "::" << DataClassName << "(RC<RawSyntax> Raw, const SyntaxData *Data, const CursorIndex IndexInParent)\n"
  "  : " << DataSuperclassName << "(Raw, Data, IndexInParent) {\n"
  "  assert(Raw->Kind == SyntaxKind::" << Kind << ");\n"
  "  assert(Raw->Layout.size() == " << getChildrenOf(Node).size() << ");\n";
  for (const auto Child : getChildrenOf(Node)) {
    auto ChildName = Child.getName();
    auto ChildType = getLayoutNodeRecord(Child);
    auto ChildVariable = "Raw->getChild(" + ClassName + "::Cursor::" + ChildName + ")";
    if (isToken(ChildType)) {
      printTokenAssertion(ChildVariable.str(), ChildType, OS);
    } else {
      printSyntaxAssertion(ChildVariable, Child, OS);
    }
  }
  OS << "}\n\n";

  // make
  OS << "RC<" << DataClassName << ">\n" <<
  DataClassName << "::make(RC<RawSyntax> Raw, const SyntaxData *Parent, const CursorIndex IndexInParent) {\n"
  "  return RC<" << DataClassName << "> {\n"
  "    new " << DataClassName << " { Raw, Parent, IndexInParent }\n"
  "  };\n"
  "}\n\n";

  // makeBlank
  OS << "RC<" << DataClassName << ">\n" <<
  DataClassName << "::makeBlank() {\n"
  "  return make(RawSyntax::make(SyntaxKind::" << Kind << ",\n"
  "  {\n";
  for (const auto Child : getChildrenOf(Node)) {
    auto ChildType = getLayoutNodeRecord(Child);
    if (isToken(ChildType)) {
      auto ChildRec = getLayoutNodeRecord(Child);
      auto TokenKind = ChildRec.getValueAsString("Kind");
      auto TokenSpelling = ChildRec.getValueAsString("Spelling");
      OS << "    RawTokenSyntax::missingToken(tok::" << TokenKind << ", \"" << TokenSpelling << "\"),\n";
    } else {
      auto ChildKind = getMissingSyntaxKind(Child);
      OS << "    RawSyntax::missing(SyntaxKind::" << ChildKind << "),\n";
    }
  }
  OS << "  },\n"
  "  SourcePresence::Present));\n"
  "}\n\n";

  return false;
}

static bool printSyntaxImplementations(raw_ostream &OS) {
  const auto Nodes = getRecordsForCategory(options::Category);
  for (const auto *Node : Nodes) {
    printAutogenReminder(OS);
    OS << "#pragma mark - " << Node->getName() << " API\n\n";
    printSyntaxImplementation(*Node, OS);
    OS << "#pragma mark - " << Node->getName() << " Data\n\n";
    printSyntaxDataImplementation(*Node, OS);
  }

  return false;
}

#pragma mark - SyntaxFactory

static bool printSyntaxFactoryInterface(raw_ostream &OS) {
  HeaderGuard HG { OS };
  Namespaces NS { OS };
  // TODO
  return false;
}


static bool printSyntaxFactoryImplementation(raw_ostream &OS) {
  // TODO
  return false;
}

#pragma mark - SyntaxRewriter

static bool printSyntaxRewriterInterface(raw_ostream &OS) {
  HeaderGuard HG { OS };
  Namespaces NS { OS };
  // TODO
  return false;
}

static bool printSyntaxRewriterImplementation(raw_ostream &OS) {
  // TODO
  return false;
}

static bool genInterface(raw_ostream &OS) {
  switch (getCategory()) {
    case Category::DeclSyntax:
    case Category::ExprSyntax:
    case Category::StmtSyntax:
    case Category::TypeSyntax:
    case Category::PatternSyntax:
    case Category::GenericSyntax:
    case Category::AttributeSyntax:
    case Category::CommonSyntax:
      return printSyntaxInterfaces(OS);
      break;
    case Category::SyntaxFactory:
      return printSyntaxFactoryInterface(OS);
      break;
    case Category::SyntaxRewriter:
      return printSyntaxRewriterInterface(OS);
      break;
    case Category::Unknown:
      llvm_unreachable("Unknown category given");
  }
}

static bool genImplementation(raw_ostream &OS) {
  printIncludesOfImplementation(OS);

  switch (getCategory()) {
    case Category::DeclSyntax:
    case Category::ExprSyntax:
    case Category::StmtSyntax:
    case Category::TypeSyntax:
    case Category::PatternSyntax:
    case Category::GenericSyntax:
    case Category::AttributeSyntax:
    case Category::CommonSyntax:
      return printSyntaxImplementations(OS);
    case Category::SyntaxFactory:
      return printSyntaxFactoryImplementation(OS);
    case Category::SyntaxRewriter:
      return printSyntaxRewriterImplementation(OS);
    case Category::Unknown:
      llvm_unreachable("Unknown category given");
  }
}

static bool SyntaxTableGenMain(raw_ostream &OS, RecordKeeper &Records) {
  AllRecords = &Records;
  SyntaxCategories.insert(AllRecords->getClass("Syntax"));
  SyntaxCategories.insert(AllRecords->getClass("DeclSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("StmtSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("ExprSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("TypeSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("PatternSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("TokenSyntax"));
  SyntaxCategories.insert(AllRecords->getClass("SyntaxCollection"));

  switch (options::Action) {
    case ActionType::None:
      llvm::errs() << "action required\n";
      llvm::cl::PrintHelpMessage();
      return true;
    case ActionType::GenInterface:
      return genInterface(OS);
    case ActionType::GenImplementation:
      return genImplementation(OS);
  }
}

int main(int argc, char **argv) {
  sys::PrintStackTraceOnErrorSignal(argv[0]);
  cl::ParseCommandLineOptions(argc, argv);
  if (getCategory() == Category::Unknown) {
    errs() << options::Category << " is an unknown category!\n";
    cl::PrintHelpMessage();
    return 1;
  }
  return TableGenMain(argv[0], &SyntaxTableGenMain);
}
