%# -*- mode: C++ -*-
%# Ignore the following admonition; it applies to the resulting .h file only
//// Automatically Generated From SyntaxFactory.h.gyb.
//// Do Not Edit Directly!
//===------------- SyntaxFactory.h - Syntax Factory definition ------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
// This file defines the SyntaxFactory, one of the most important client-facing
// types in lib/Syntax and likely to be very commonly used.
//
// Effectively a namespace, SyntaxFactory is never instantiated, but is *the*
// one-stop shop for making new Syntax nodes. Putting all of these into a
// collection of static methods provides a single point of API lookup for
// clients' convenience and also allows the library to hide all of the
// constructors for all Syntax nodes, as the SyntaxFactory is friend to all.
//
//===----------------------------------------------------------------------===//
%{
    from gyb_syntax_support import *
    nodes = load_all_syntax_nodes()
}%
#include "swift/Syntax/SyntaxNodes.h"
#include "swift/Syntax/Trivia.h"
#include "llvm/ADT/ArrayRef.h"

#include <vector>

namespace swift {
namespace syntax {

TokenSyntax
SyntaxFactory::makeToken(tok Kind, OwnedString Text, SourcePresence Presence,
                         const Trivia &LeadingTrivia,
                         const Trivia &TrailingTrivia) {
  return make<TokenSyntax>(RawTokenSyntax::make(Kind, Text, Presence,
                                                LeadingTrivia, TrailingTrivia));
}

UnknownSyntax
SyntaxFactory::makeUnknownSyntax(llvm::ArrayRef<TokenSyntax> Tokens) {
  RawSyntax::LayoutList Layout;
  for (auto &Token : Tokens) {
    Layout.push_back(Token.getRaw());
  }
  auto Raw = RawSyntax::make(SyntaxKind::Unknown, Layout,
                             SourcePresence::Present);
  return make<UnknownSyntax>(Raw);
}

% for node in nodes:
%   if node.has_children():
${node.name}
SyntaxFactory::make${node.capital_syntax_kind}(
%     for child in node.children:
    ${child.type_name} ${child.name},
%     end
) {
  auto Raw = RawSyntax::make(SyntaxKind::${node.capital_syntax_kind}, {
%     for child in node.children:
    ${child.name}.getRaw(),
%     end
  }, SourcePresence::Present);
  return make<${node.name}>(Raw);
}
%   elif node.is_syntax_collection():
${node.name}
SyntaxFactory::make${node.capital_syntax_kind}(
  std::vector<${node.collection_element}> elts) {
  RawSyntax::LayoutList layout;
  for (auto elt : elts) {
    Layout.push_back(elt.getRaw());
  }
  auto Raw = RawSyntax::make(SyntaxKind::${node.capital_syntax_kind},
                             layout, SourcePresence::Present);
  return make<${node.name}>(Raw);
}
%   end

${node.name}
SyntaxFactory::makeBlank${node.capital_syntax_kind}() {

}

% end

};
}
}