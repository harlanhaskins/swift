//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

// This file autogenerated by swift-syntax-tblgen - DO NOT EDIT!

/// MARK: AttributeSyntax Data

/// MARK: AttributeSyntax API

public struct AttributeSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var atSignToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.atSignToken))
  }

  public func withAtSignToken(_ newAtSignToken: TokenSyntax) -> AttributeSyntax {
    guard case .token(.at_sign, _, _, _) = newAtSignToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newAtSignToken.raw,
                                              at: Cursor.atSignToken)
    return AttributeSyntax(root: root, data: newData)
  }

  public var attributeNameToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.attributeNameToken))
  }

  public func withAttributeNameToken(_ newAttributeNameToken: TokenSyntax) -> AttributeSyntax {
    guard case .token(.identifier, _, _, _) = newAttributeNameToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newAttributeNameToken.raw,
                                              at: Cursor.attributeNameToken)
    return AttributeSyntax(root: root, data: newData)
  }

  public var openParenToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.openParenToken))
  }

  public func withOpenParenToken(_ newOpenParenToken: TokenSyntax) -> AttributeSyntax {
    guard case .token(.l_paren, _, _, _) = newOpenParenToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newOpenParenToken.raw,
                                              at: Cursor.openParenToken)
    return AttributeSyntax(root: root, data: newData)
  }

  public var attributeArguments: AttributeArgumentListSyntax {
    return AttributeArgumentListSyntax(root: root, data: data.cachedChild(at: Cursor.attributeArguments))
  }

  public func withAttributeArguments(_ newAttributeArguments: AttributeArgumentListSyntax) -> AttributeSyntax {
    let (root, newData) = data.replacingChild(newAttributeArguments.raw,
                                              at: Cursor.attributeArguments)
    return AttributeSyntax(root: root, data: newData)
  }

  public var closeParenToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.closeParenToken))
  }

  public func withCloseParenToken(_ newCloseParenToken: TokenSyntax) -> AttributeSyntax {
    guard case .token(.r_paren, _, _, _) = newCloseParenToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCloseParenToken.raw,
                                              at: Cursor.closeParenToken)
    return AttributeSyntax(root: root, data: newData)
  }

}

/// MARK: AvailabilityArgumentList Data

/// MARK: AvailabilityArgumentList API

public struct AvailabilityArgumentList: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: AvailabilityArgumentSyntax Data

/// MARK: AvailabilityArgumentSyntax API

public struct AvailabilityArgumentSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var platformNameToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.platformNameToken))
  }

  public func withPlatformNameToken(_ newPlatformNameToken: TokenSyntax) -> AvailabilityArgumentSyntax {
    guard case .token(.identifier, _, _, _) = newPlatformNameToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newPlatformNameToken.raw,
                                              at: Cursor.platformNameToken)
    return AvailabilityArgumentSyntax(root: root, data: newData)
  }

  public var platformVersion: PlatformVersionSyntax {
    return PlatformVersionSyntax(root: root, data: data.cachedChild(at: Cursor.platformVersion))
  }

  public func withPlatformVersion(_ newPlatformVersion: PlatformVersionSyntax) -> AvailabilityArgumentSyntax {
    let (root, newData) = data.replacingChild(newPlatformVersion.raw,
                                              at: Cursor.platformVersion)
    return AvailabilityArgumentSyntax(root: root, data: newData)
  }

  public var commaToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.commaToken))
  }

  public func withCommaToken(_ newCommaToken: TokenSyntax) -> AvailabilityArgumentSyntax {
    guard case .token(.comma, _, _, _) = newCommaToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCommaToken.raw,
                                              at: Cursor.commaToken)
    return AvailabilityArgumentSyntax(root: root, data: newData)
  }

}

/// MARK: AvailabilityConditionSyntax Data

/// MARK: AvailabilityConditionSyntax API

public struct AvailabilityConditionSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var availableToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.availableToken))
  }

  public func withAvailableToken(_ newAvailableToken: TokenSyntax) -> AvailabilityConditionSyntax {
    guard case .token(.pound_available, _, _, _) = newAvailableToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newAvailableToken.raw,
                                              at: Cursor.availableToken)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }

  public var openParenToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.openParenToken))
  }

  public func withOpenParenToken(_ newOpenParenToken: TokenSyntax) -> AvailabilityConditionSyntax {
    guard case .token(.l_paren, _, _, _) = newOpenParenToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newOpenParenToken.raw,
                                              at: Cursor.openParenToken)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }

  public var availabilityArguments: AvailabilityArgumentList {
    return AvailabilityArgumentList(root: root, data: data.cachedChild(at: Cursor.availabilityArguments))
  }

  public func withAvailabilityArguments(_ newAvailabilityArguments: AvailabilityArgumentList) -> AvailabilityConditionSyntax {
    let (root, newData) = data.replacingChild(newAvailabilityArguments.raw,
                                              at: Cursor.availabilityArguments)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }

  public var closeParenToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.closeParenToken))
  }

  public func withCloseParenToken(_ newCloseParenToken: TokenSyntax) -> AvailabilityConditionSyntax {
    guard case .token(.r_paren, _, _, _) = newCloseParenToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCloseParenToken.raw,
                                              at: Cursor.closeParenToken)
    return AvailabilityConditionSyntax(root: root, data: newData)
  }

}

/// MARK: BalancedTokenSyntaxsSyntax Data

/// MARK: BalancedTokenSyntaxsSyntax API

public struct BalancedTokenSyntaxsSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var leftMatchToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.leftMatchToken))
  }

  public func withLeftMatchToken(_ newLeftMatchToken: TokenSyntax) -> BalancedTokenSyntaxsSyntax {
    guard case .token = newLeftMatchToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newLeftMatchToken.raw,
                                              at: Cursor.leftMatchToken)
    return BalancedTokenSyntaxsSyntax(root: root, data: newData)
  }

  public var balancedTokenSyntaxs: AttributeArgumentListSyntax {
    return AttributeArgumentListSyntax(root: root, data: data.cachedChild(at: Cursor.balancedTokenSyntaxs))
  }

  public func withBalancedTokenSyntaxs(_ newBalancedTokenSyntaxs: AttributeArgumentListSyntax) -> BalancedTokenSyntaxsSyntax {
    let (root, newData) = data.replacingChild(newBalancedTokenSyntaxs.raw,
                                              at: Cursor.balancedTokenSyntaxs)
    return BalancedTokenSyntaxsSyntax(root: root, data: newData)
  }

  public var rightMatchToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.rightMatchToken))
  }

  public func withRightMatchToken(_ newRightMatchToken: TokenSyntax) -> BalancedTokenSyntaxsSyntax {
    guard case .token = newRightMatchToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newRightMatchToken.raw,
                                              at: Cursor.rightMatchToken)
    return BalancedTokenSyntaxsSyntax(root: root, data: newData)
  }

}

/// MARK: BindingConditionSyntax Data

/// MARK: BindingConditionSyntax API

public struct BindingConditionSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var keywordToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.keywordToken))
  }

  public func withKeywordToken(_ newKeywordToken: TokenSyntax) -> BindingConditionSyntax {
    guard case .token = newKeywordToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newKeywordToken.raw,
                                              at: Cursor.keywordToken)
    return BindingConditionSyntax(root: root, data: newData)
  }

  public var pattern: PatternSyntax {
    return PatternSyntax(root: root, data: data.cachedChild(at: Cursor.pattern))
  }

  public func withPattern(_ newPattern: PatternSyntax) -> BindingConditionSyntax {
    let (root, newData) = data.replacingChild(newPattern.raw,
                                              at: Cursor.pattern)
    return BindingConditionSyntax(root: root, data: newData)
  }

  public var initializer: ExprSyntax {
    return ExprSyntax(root: root, data: data.cachedChild(at: Cursor.initializer))
  }

  public func withInitializer(_ newInitializer: ExprSyntax) -> BindingConditionSyntax {
    let (root, newData) = data.replacingChild(newInitializer.raw,
                                              at: Cursor.initializer)
    return BindingConditionSyntax(root: root, data: newData)
  }

}

/// MARK: BooleanConditionSyntax Data

/// MARK: BooleanConditionSyntax API

public struct BooleanConditionSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var expression: ExprSyntax {
    return ExprSyntax(root: root, data: data.cachedChild(at: Cursor.expression))
  }

  public func withExpression(_ newExpression: ExprSyntax) -> BooleanConditionSyntax {
    let (root, newData) = data.replacingChild(newExpression.raw,
                                              at: Cursor.expression)
    return BooleanConditionSyntax(root: root, data: newData)
  }

}

/// MARK: CaseItemListSyntax Data

/// MARK: CaseItemListSyntax API

public struct CaseItemListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: CaseItemSyntax Data

/// MARK: CaseItemSyntax API

public struct CaseItemSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var pattern: PatternSyntax {
    return PatternSyntax(root: root, data: data.cachedChild(at: Cursor.pattern))
  }

  public func withPattern(_ newPattern: PatternSyntax) -> CaseItemSyntax {
    let (root, newData) = data.replacingChild(newPattern.raw,
                                              at: Cursor.pattern)
    return CaseItemSyntax(root: root, data: newData)
  }

  public var whereClause: WhereClauseSyntax {
    return WhereClauseSyntax(root: root, data: data.cachedChild(at: Cursor.whereClause))
  }

  public func withWhereClause(_ newWhereClause: WhereClauseSyntax) -> CaseItemSyntax {
    let (root, newData) = data.replacingChild(newWhereClause.raw,
                                              at: Cursor.whereClause)
    return CaseItemSyntax(root: root, data: newData)
  }

  public var commaToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.commaToken))
  }

  public func withCommaToken(_ newCommaToken: TokenSyntax) -> CaseItemSyntax {
    guard case .token(.comma, _, _, _) = newCommaToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCommaToken.raw,
                                              at: Cursor.commaToken)
    return CaseItemSyntax(root: root, data: newData)
  }

}

/// MARK: CatchClauseListSyntax Data

/// MARK: CatchClauseListSyntax API

public struct CatchClauseListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: CatchClauseSyntax Data

/// MARK: CatchClauseSyntax API

public struct CatchClauseSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var catchToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.catchToken))
  }

  public func withCatchToken(_ newCatchToken: TokenSyntax) -> CatchClauseSyntax {
    guard case .token(.kw_catch, _, _, _) = newCatchToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCatchToken.raw,
                                              at: Cursor.catchToken)
    return CatchClauseSyntax(root: root, data: newData)
  }

  public var pattern: PatternSyntax {
    return PatternSyntax(root: root, data: data.cachedChild(at: Cursor.pattern))
  }

  public func withPattern(_ newPattern: PatternSyntax) -> CatchClauseSyntax {
    let (root, newData) = data.replacingChild(newPattern.raw,
                                              at: Cursor.pattern)
    return CatchClauseSyntax(root: root, data: newData)
  }

  public var whereClause: WhereClauseSyntax {
    return WhereClauseSyntax(root: root, data: data.cachedChild(at: Cursor.whereClause))
  }

  public func withWhereClause(_ newWhereClause: WhereClauseSyntax) -> CatchClauseSyntax {
    let (root, newData) = data.replacingChild(newWhereClause.raw,
                                              at: Cursor.whereClause)
    return CatchClauseSyntax(root: root, data: newData)
  }

  public var body: CodeBlockSyntax {
    return CodeBlockSyntax(root: root, data: data.cachedChild(at: Cursor.body))
  }

  public func withBody(_ newBody: CodeBlockSyntax) -> CatchClauseSyntax {
    let (root, newData) = data.replacingChild(newBody.raw,
                                              at: Cursor.body)
    return CatchClauseSyntax(root: root, data: newData)
  }

}

/// MARK: CodeBlockSyntax Data

/// MARK: CodeBlockSyntax API

public struct CodeBlockSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var openBraceToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.openBraceToken))
  }

  public func withOpenBraceToken(_ newOpenBraceToken: TokenSyntax) -> CodeBlockSyntax {
    guard case .token(.l_brace, _, _, _) = newOpenBraceToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newOpenBraceToken.raw,
                                              at: Cursor.openBraceToken)
    return CodeBlockSyntax(root: root, data: newData)
  }

  public var statments: StatementListSyntax {
    return StatementListSyntax(root: root, data: data.cachedChild(at: Cursor.statments))
  }

  public func withStatments(_ newStatments: StatementListSyntax) -> CodeBlockSyntax {
    let (root, newData) = data.replacingChild(newStatments.raw,
                                              at: Cursor.statments)
    return CodeBlockSyntax(root: root, data: newData)
  }

  public var closeBraceToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.closeBraceToken))
  }

  public func withCloseBraceToken(_ newCloseBraceToken: TokenSyntax) -> CodeBlockSyntax {
    guard case .token(.r_brace, _, _, _) = newCloseBraceToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCloseBraceToken.raw,
                                              at: Cursor.closeBraceToken)
    return CodeBlockSyntax(root: root, data: newData)
  }

}

/// MARK: ConditionListElementSyntax Data

/// MARK: ConditionListElementSyntax API

public struct ConditionListElementSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var condition: AnyCondition {
    return AnyCondition(root: root, data: data.cachedChild(at: Cursor.condition))
  }

  public func withCondition(_ newCondition: AnyCondition) -> ConditionListElementSyntax {
    let (root, newData) = data.replacingChild(newCondition.raw,
                                              at: Cursor.condition)
    return ConditionListElementSyntax(root: root, data: newData)
  }

  public var commaToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.commaToken))
  }

  public func withCommaToken(_ newCommaToken: TokenSyntax) -> ConditionListElementSyntax {
    guard case .token(.comma, _, _, _) = newCommaToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCommaToken.raw,
                                              at: Cursor.commaToken)
    return ConditionListElementSyntax(root: root, data: newData)
  }

}

/// MARK: ConditionListSyntax Data

/// MARK: ConditionListSyntax API

public struct ConditionListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: ElseBlockSyntax Data

/// MARK: ElseBlockSyntax API

public struct ElseBlockSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var elseToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.elseToken))
  }

  public func withElseToken(_ newElseToken: TokenSyntax) -> ElseBlockSyntax {
    guard case .token(.kw_else, _, _, _) = newElseToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newElseToken.raw,
                                              at: Cursor.elseToken)
    return ElseBlockSyntax(root: root, data: newData)
  }

  public var body: CodeBlockSyntax {
    return CodeBlockSyntax(root: root, data: data.cachedChild(at: Cursor.body))
  }

  public func withBody(_ newBody: CodeBlockSyntax) -> ElseBlockSyntax {
    let (root, newData) = data.replacingChild(newBody.raw,
                                              at: Cursor.body)
    return ElseBlockSyntax(root: root, data: newData)
  }

}

/// MARK: ElseDirectiveClause Data

/// MARK: ElseDirectiveClause API

public struct ElseDirectiveClause: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var poundElseToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.poundElseToken))
  }

  public func withPoundElseToken(_ newPoundElseToken: TokenSyntax) -> ElseDirectiveClause {
    guard case .token(.pound_else, _, _, _) = newPoundElseToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newPoundElseToken.raw,
                                              at: Cursor.poundElseToken)
    return ElseDirectiveClause(root: root, data: newData)
  }

  public var body: StatementListSyntax {
    return StatementListSyntax(root: root, data: data.cachedChild(at: Cursor.body))
  }

  public func withBody(_ newBody: StatementListSyntax) -> ElseDirectiveClause {
    let (root, newData) = data.replacingChild(newBody.raw,
                                              at: Cursor.body)
    return ElseDirectiveClause(root: root, data: newData)
  }

}

/// MARK: ElseIfContinuationSyntax Data

/// MARK: ElseIfContinuationSyntax API

public struct ElseIfContinuationSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var elseToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.elseToken))
  }

  public func withElseToken(_ newElseToken: TokenSyntax) -> ElseIfContinuationSyntax {
    guard case .token(.kw_else, _, _, _) = newElseToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newElseToken.raw,
                                              at: Cursor.elseToken)
    return ElseIfContinuationSyntax(root: root, data: newData)
  }

  public var ifStmtSyntaxToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.ifStmtSyntaxToken))
  }

  public func withIfStmtSyntaxToken(_ newIfStmtSyntaxToken: TokenSyntax) -> ElseIfContinuationSyntax {
    guard case .token(.kw_else, _, _, _) = newIfStmtSyntaxToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newIfStmtSyntaxToken.raw,
                                              at: Cursor.ifStmtSyntaxToken)
    return ElseIfContinuationSyntax(root: root, data: newData)
  }

}

/// MARK: ElseifDirectiveClause Data

/// MARK: ElseifDirectiveClause API

public struct ElseifDirectiveClause: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var poundElseifToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.poundElseifToken))
  }

  public func withPoundElseifToken(_ newPoundElseifToken: TokenSyntax) -> ElseifDirectiveClause {
    guard case .token(.pound_elseif, _, _, _) = newPoundElseifToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newPoundElseifToken.raw,
                                              at: Cursor.poundElseifToken)
    return ElseifDirectiveClause(root: root, data: newData)
  }

  public var condition: ExprSyntax {
    return ExprSyntax(root: root, data: data.cachedChild(at: Cursor.condition))
  }

  public func withCondition(_ newCondition: ExprSyntax) -> ElseifDirectiveClause {
    let (root, newData) = data.replacingChild(newCondition.raw,
                                              at: Cursor.condition)
    return ElseifDirectiveClause(root: root, data: newData)
  }

  public var body: StatementListSyntax {
    return StatementListSyntax(root: root, data: data.cachedChild(at: Cursor.body))
  }

  public func withBody(_ newBody: StatementListSyntax) -> ElseifDirectiveClause {
    let (root, newData) = data.replacingChild(newBody.raw,
                                              at: Cursor.body)
    return ElseifDirectiveClause(root: root, data: newData)
  }

}

/// MARK: ElseifDirectiveClauseListSyntax Data

/// MARK: ElseifDirectiveClauseListSyntax API

public struct ElseifDirectiveClauseListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: FunctionTypeArgumentListSyntax Data

/// MARK: FunctionTypeArgumentListSyntax API

public struct FunctionTypeArgumentListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: FunctionTypeArgumentSyntax Data

/// MARK: FunctionTypeArgumentSyntax API

public struct FunctionTypeArgumentSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var externalParameterNameToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.externalParameterNameToken))
  }

  public func withExternalParameterNameToken(_ newExternalParameterNameToken: TokenSyntax) -> FunctionTypeArgumentSyntax {
    guard case .token(.identifier, _, _, _) = newExternalParameterNameToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newExternalParameterNameToken.raw,
                                              at: Cursor.externalParameterNameToken)
    return FunctionTypeArgumentSyntax(root: root, data: newData)
  }

  public var localParameterNameToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.localParameterNameToken))
  }

  public func withLocalParameterNameToken(_ newLocalParameterNameToken: TokenSyntax) -> FunctionTypeArgumentSyntax {
    guard case .token(.identifier, _, _, _) = newLocalParameterNameToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newLocalParameterNameToken.raw,
                                              at: Cursor.localParameterNameToken)
    return FunctionTypeArgumentSyntax(root: root, data: newData)
  }

  public var colonToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.colonToken))
  }

  public func withColonToken(_ newColonToken: TokenSyntax) -> FunctionTypeArgumentSyntax {
    guard case .token(.colon, _, _, _) = newColonToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newColonToken.raw,
                                              at: Cursor.colonToken)
    return FunctionTypeArgumentSyntax(root: root, data: newData)
  }

  public var typeAttributes: anonymous_152 {
    return anonymous_152(root: root, data: data.cachedChild(at: Cursor.typeAttributes))
  }

  public func withTypeAttributes(_ newTypeAttributes: anonymous_152) -> FunctionTypeArgumentSyntax {
    let (root, newData) = data.replacingChild(newTypeAttributes.raw,
                                              at: Cursor.typeAttributes)
    return FunctionTypeArgumentSyntax(root: root, data: newData)
  }

  public var inoutToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.inoutToken))
  }

  public func withInoutToken(_ newInoutToken: TokenSyntax) -> FunctionTypeArgumentSyntax {
    guard case .token(.kw_inout, _, _, _) = newInoutToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newInoutToken.raw,
                                              at: Cursor.inoutToken)
    return FunctionTypeArgumentSyntax(root: root, data: newData)
  }

  public var type: TypeSyntax {
    return TypeSyntax(root: root, data: data.cachedChild(at: Cursor.type))
  }

  public func withType(_ newType: TypeSyntax) -> FunctionTypeArgumentSyntax {
    let (root, newData) = data.replacingChild(newType.raw,
                                              at: Cursor.type)
    return FunctionTypeArgumentSyntax(root: root, data: newData)
  }

}

/// MARK: GenericArgumentClauseElementSyntax Data

/// MARK: GenericArgumentClauseElementSyntax API

public struct GenericArgumentClauseElementSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var genericArgument: TypeSyntax {
    return TypeSyntax(root: root, data: data.cachedChild(at: Cursor.genericArgument))
  }

  public func withGenericArgument(_ newGenericArgument: TypeSyntax) -> GenericArgumentClauseElementSyntax {
    let (root, newData) = data.replacingChild(newGenericArgument.raw,
                                              at: Cursor.genericArgument)
    return GenericArgumentClauseElementSyntax(root: root, data: newData)
  }

  public var commaToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.commaToken))
  }

  public func withCommaToken(_ newCommaToken: TokenSyntax) -> GenericArgumentClauseElementSyntax {
    guard case .token(.comma, _, _, _) = newCommaToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCommaToken.raw,
                                              at: Cursor.commaToken)
    return GenericArgumentClauseElementSyntax(root: root, data: newData)
  }

}

/// MARK: GenericArgumentClauseSyntax Data

/// MARK: GenericArgumentClauseSyntax API

public struct GenericArgumentClauseSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: LabelSyntax Data

/// MARK: LabelSyntax API

public struct LabelSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var identifierToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.identifierToken))
  }

  public func withIdentifierToken(_ newIdentifierToken: TokenSyntax) -> LabelSyntax {
    guard case .token(.identifier, _, _, _) = newIdentifierToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newIdentifierToken.raw,
                                              at: Cursor.identifierToken)
    return LabelSyntax(root: root, data: newData)
  }

  public var colonToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.colonToken))
  }

  public func withColonToken(_ newColonToken: TokenSyntax) -> LabelSyntax {
    guard case .token(.colon, _, _, _) = newColonToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newColonToken.raw,
                                              at: Cursor.colonToken)
    return LabelSyntax(root: root, data: newData)
  }

}

/// MARK: LineControlSpecSyntax Data

/// MARK: LineControlSpecSyntax API

public struct LineControlSpecSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var fileToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.fileToken))
  }

  public func withFileToken(_ newFileToken: TokenSyntax) -> LineControlSpecSyntax {
    guard case .token(.identifier, _, _, _) = newFileToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newFileToken.raw,
                                              at: Cursor.fileToken)
    return LineControlSpecSyntax(root: root, data: newData)
  }

  public var fileColonToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.fileColonToken))
  }

  public func withFileColonToken(_ newFileColonToken: TokenSyntax) -> LineControlSpecSyntax {
    guard case .token(.colon, _, _, _) = newFileColonToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newFileColonToken.raw,
                                              at: Cursor.fileColonToken)
    return LineControlSpecSyntax(root: root, data: newData)
  }

  public var fileValueToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.fileValueToken))
  }

  public func withFileValueToken(_ newFileValueToken: TokenSyntax) -> LineControlSpecSyntax {
    guard case .token(.string_literal, _, _, _) = newFileValueToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newFileValueToken.raw,
                                              at: Cursor.fileValueToken)
    return LineControlSpecSyntax(root: root, data: newData)
  }

  public var commaToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.commaToken))
  }

  public func withCommaToken(_ newCommaToken: TokenSyntax) -> LineControlSpecSyntax {
    guard case .token(.comma, _, _, _) = newCommaToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCommaToken.raw,
                                              at: Cursor.commaToken)
    return LineControlSpecSyntax(root: root, data: newData)
  }

  public var lineToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.lineToken))
  }

  public func withLineToken(_ newLineToken: TokenSyntax) -> LineControlSpecSyntax {
    guard case .token(.identifier, _, _, _) = newLineToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newLineToken.raw,
                                              at: Cursor.lineToken)
    return LineControlSpecSyntax(root: root, data: newData)
  }

  public var lineColonToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.lineColonToken))
  }

  public func withLineColonToken(_ newLineColonToken: TokenSyntax) -> LineControlSpecSyntax {
    guard case .token(.colon, _, _, _) = newLineColonToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newLineColonToken.raw,
                                              at: Cursor.lineColonToken)
    return LineControlSpecSyntax(root: root, data: newData)
  }

  public var lineValueToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.lineValueToken))
  }

  public func withLineValueToken(_ newLineValueToken: TokenSyntax) -> LineControlSpecSyntax {
    guard case .token(.integer_literal, _, _, _) = newLineValueToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newLineValueToken.raw,
                                              at: Cursor.lineValueToken)
    return LineControlSpecSyntax(root: root, data: newData)
  }

}

/// MARK: PlatformVersionSyntax Data

/// MARK: PlatformVersionSyntax API

public struct PlatformVersionSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var majorVersionToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.majorVersionToken))
  }

  public func withMajorVersionToken(_ newMajorVersionToken: TokenSyntax) -> PlatformVersionSyntax {
    guard case .token(.integer_literal, _, _, _) = newMajorVersionToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newMajorVersionToken.raw,
                                              at: Cursor.majorVersionToken)
    return PlatformVersionSyntax(root: root, data: newData)
  }

  public var minorPeriodToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.minorPeriodToken))
  }

  public func withMinorPeriodToken(_ newMinorPeriodToken: TokenSyntax) -> PlatformVersionSyntax {
    guard case .token(.period, _, _, _) = newMinorPeriodToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newMinorPeriodToken.raw,
                                              at: Cursor.minorPeriodToken)
    return PlatformVersionSyntax(root: root, data: newData)
  }

  public var minorVersionToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.minorVersionToken))
  }

  public func withMinorVersionToken(_ newMinorVersionToken: TokenSyntax) -> PlatformVersionSyntax {
    guard case .token(.integer_literal, _, _, _) = newMinorVersionToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newMinorVersionToken.raw,
                                              at: Cursor.minorVersionToken)
    return PlatformVersionSyntax(root: root, data: newData)
  }

  public var bugfixPeriodToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.bugfixPeriodToken))
  }

  public func withBugfixPeriodToken(_ newBugfixPeriodToken: TokenSyntax) -> PlatformVersionSyntax {
    guard case .token(.period, _, _, _) = newBugfixPeriodToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newBugfixPeriodToken.raw,
                                              at: Cursor.bugfixPeriodToken)
    return PlatformVersionSyntax(root: root, data: newData)
  }

  public var bugfixVersionToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.bugfixVersionToken))
  }

  public func withBugfixVersionToken(_ newBugfixVersionToken: TokenSyntax) -> PlatformVersionSyntax {
    guard case .token(.integer_literal, _, _, _) = newBugfixVersionToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newBugfixVersionToken.raw,
                                              at: Cursor.bugfixVersionToken)
    return PlatformVersionSyntax(root: root, data: newData)
  }

}

/// MARK: ProtocolCompositionElementSyntax Data

/// MARK: ProtocolCompositionElementSyntax API

public struct ProtocolCompositionElementSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var protocolType: TypeIdentifierSyntax {
    return TypeIdentifierSyntax(root: root, data: data.cachedChild(at: Cursor.protocolType))
  }

  public func withProtocolType(_ newProtocolType: TypeIdentifierSyntax) -> ProtocolCompositionElementSyntax {
    let (root, newData) = data.replacingChild(newProtocolType.raw,
                                              at: Cursor.protocolType)
    return ProtocolCompositionElementSyntax(root: root, data: newData)
  }

  public var ampersandToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.ampersandToken))
  }

  public func withAmpersandToken(_ newAmpersandToken: TokenSyntax) -> ProtocolCompositionElementSyntax {
    guard case .token(.amp_prefix, _, _, _) = newAmpersandToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newAmpersandToken.raw,
                                              at: Cursor.ampersandToken)
    return ProtocolCompositionElementSyntax(root: root, data: newData)
  }

}

/// MARK: ProtocolCompositionTypeSyntax Data

/// MARK: ProtocolCompositionTypeSyntax API

public struct ProtocolCompositionTypeSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: StatementListSyntax Data

/// MARK: StatementListSyntax API

public struct StatementListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: SwitchCaseLabelSyntax Data

/// MARK: SwitchCaseLabelSyntax API

public struct SwitchCaseLabelSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var caseToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.caseToken))
  }

  public func withCaseToken(_ newCaseToken: TokenSyntax) -> SwitchCaseLabelSyntax {
    guard case .token(.kw_case, _, _, _) = newCaseToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCaseToken.raw,
                                              at: Cursor.caseToken)
    return SwitchCaseLabelSyntax(root: root, data: newData)
  }

  public var caseItems: CaseItemListSyntax {
    return CaseItemListSyntax(root: root, data: data.cachedChild(at: Cursor.caseItems))
  }

  public func withCaseItems(_ newCaseItems: CaseItemListSyntax) -> SwitchCaseLabelSyntax {
    let (root, newData) = data.replacingChild(newCaseItems.raw,
                                              at: Cursor.caseItems)
    return SwitchCaseLabelSyntax(root: root, data: newData)
  }

  public var colonToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.colonToken))
  }

  public func withColonToken(_ newColonToken: TokenSyntax) -> SwitchCaseLabelSyntax {
    guard case .token(.colon, _, _, _) = newColonToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newColonToken.raw,
                                              at: Cursor.colonToken)
    return SwitchCaseLabelSyntax(root: root, data: newData)
  }

}

/// MARK: SwitchCaseListSyntax Data

/// MARK: SwitchCaseListSyntax API

public struct SwitchCaseListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: SwitchCaseSyntax Data

/// MARK: SwitchCaseSyntax API

public struct SwitchCaseSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var label: AnySwitchLabel {
    return AnySwitchLabel(root: root, data: data.cachedChild(at: Cursor.label))
  }

  public func withLabel(_ newLabel: AnySwitchLabel) -> SwitchCaseSyntax {
    let (root, newData) = data.replacingChild(newLabel.raw,
                                              at: Cursor.label)
    return SwitchCaseSyntax(root: root, data: newData)
  }

  public var body: StatementListSyntax {
    return StatementListSyntax(root: root, data: data.cachedChild(at: Cursor.body))
  }

  public func withBody(_ newBody: StatementListSyntax) -> SwitchCaseSyntax {
    let (root, newData) = data.replacingChild(newBody.raw,
                                              at: Cursor.body)
    return SwitchCaseSyntax(root: root, data: newData)
  }

}

/// MARK: SwitchDefaultLabelSyntax Data

/// MARK: SwitchDefaultLabelSyntax API

public struct SwitchDefaultLabelSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var defaultToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.defaultToken))
  }

  public func withDefaultToken(_ newDefaultToken: TokenSyntax) -> SwitchDefaultLabelSyntax {
    guard case .token(.kw_default, _, _, _) = newDefaultToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newDefaultToken.raw,
                                              at: Cursor.defaultToken)
    return SwitchDefaultLabelSyntax(root: root, data: newData)
  }

  public var colonToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.colonToken))
  }

  public func withColonToken(_ newColonToken: TokenSyntax) -> SwitchDefaultLabelSyntax {
    guard case .token(.colon, _, _, _) = newColonToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newColonToken.raw,
                                              at: Cursor.colonToken)
    return SwitchDefaultLabelSyntax(root: root, data: newData)
  }

}

/// MARK: TokenSyntaxListSyntax Data

/// MARK: TokenSyntaxListSyntax API

public struct TokenSyntaxListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: TuplePatternElementListSyntax Data

/// MARK: TuplePatternElementListSyntax API

public struct TuplePatternElementListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: TuplePatternElementSyntax Data

/// MARK: TuplePatternElementSyntax API

public struct TuplePatternElementSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var label: LabelSyntax {
    return LabelSyntax(root: root, data: data.cachedChild(at: Cursor.label))
  }

  public func withLabel(_ newLabel: LabelSyntax) -> TuplePatternElementSyntax {
    let (root, newData) = data.replacingChild(newLabel.raw,
                                              at: Cursor.label)
    return TuplePatternElementSyntax(root: root, data: newData)
  }

  public var patternSyntax: PatternSyntax {
    return PatternSyntax(root: root, data: data.cachedChild(at: Cursor.patternSyntax))
  }

  public func withPatternSyntax(_ newPatternSyntax: PatternSyntax) -> TuplePatternElementSyntax {
    let (root, newData) = data.replacingChild(newPatternSyntax.raw,
                                              at: Cursor.patternSyntax)
    return TuplePatternElementSyntax(root: root, data: newData)
  }

  public var comma: LabelSyntax {
    return LabelSyntax(root: root, data: data.cachedChild(at: Cursor.comma))
  }

  public func withComma(_ newComma: LabelSyntax) -> TuplePatternElementSyntax {
    let (root, newData) = data.replacingChild(newComma.raw,
                                              at: Cursor.comma)
    return TuplePatternElementSyntax(root: root, data: newData)
  }

}

/// MARK: TupleTypeElementListSyntax Data

/// MARK: TupleTypeElementListSyntax API

public struct TupleTypeElementListSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

}

/// MARK: TupleTypeElementSyntax Data

/// MARK: TupleTypeElementSyntax API

public struct TupleTypeElementSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var labelToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.labelToken))
  }

  public func withLabelToken(_ newLabelToken: TokenSyntax) -> TupleTypeElementSyntax {
    guard case .token(.identifier, _, _, _) = newLabelToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newLabelToken.raw,
                                              at: Cursor.labelToken)
    return TupleTypeElementSyntax(root: root, data: newData)
  }

  public var colonToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.colonToken))
  }

  public func withColonToken(_ newColonToken: TokenSyntax) -> TupleTypeElementSyntax {
    guard case .token(.colon, _, _, _) = newColonToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newColonToken.raw,
                                              at: Cursor.colonToken)
    return TupleTypeElementSyntax(root: root, data: newData)
  }

  public var typeAttributes: anonymous_141 {
    return anonymous_141(root: root, data: data.cachedChild(at: Cursor.typeAttributes))
  }

  public func withTypeAttributes(_ newTypeAttributes: anonymous_141) -> TupleTypeElementSyntax {
    let (root, newData) = data.replacingChild(newTypeAttributes.raw,
                                              at: Cursor.typeAttributes)
    return TupleTypeElementSyntax(root: root, data: newData)
  }

  public var inOutToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.inOutToken))
  }

  public func withInOutToken(_ newInOutToken: TokenSyntax) -> TupleTypeElementSyntax {
    guard case .token(.kw_inout, _, _, _) = newInOutToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newInOutToken.raw,
                                              at: Cursor.inOutToken)
    return TupleTypeElementSyntax(root: root, data: newData)
  }

  public var type: TypeSyntax {
    return TypeSyntax(root: root, data: data.cachedChild(at: Cursor.type))
  }

  public func withType(_ newType: TypeSyntax) -> TupleTypeElementSyntax {
    let (root, newData) = data.replacingChild(newType.raw,
                                              at: Cursor.type)
    return TupleTypeElementSyntax(root: root, data: newData)
  }

  public var commaToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.commaToken))
  }

  public func withCommaToken(_ newCommaToken: TokenSyntax) -> TupleTypeElementSyntax {
    guard case .token(.comma, _, _, _) = newCommaToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newCommaToken.raw,
                                              at: Cursor.commaToken)
    return TupleTypeElementSyntax(root: root, data: newData)
  }

}

/// MARK: TypeAnnotationSyntax Data

/// MARK: TypeAnnotationSyntax API

public struct TypeAnnotationSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var attributes: AttributeListSyntax {
    return AttributeListSyntax(root: root, data: data.cachedChild(at: Cursor.attributes))
  }

  public func withAttributes(_ newAttributes: AttributeListSyntax) -> TypeAnnotationSyntax {
    let (root, newData) = data.replacingChild(newAttributes.raw,
                                              at: Cursor.attributes)
    return TypeAnnotationSyntax(root: root, data: newData)
  }

  public var inOutToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.inOutToken))
  }

  public func withInOutToken(_ newInOutToken: TokenSyntax) -> TypeAnnotationSyntax {
    guard case .token(.kw_inout, _, _, _) = newInOutToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newInOutToken.raw,
                                              at: Cursor.inOutToken)
    return TypeAnnotationSyntax(root: root, data: newData)
  }

  public var type: TypeSyntax {
    return TypeSyntax(root: root, data: data.cachedChild(at: Cursor.type))
  }

  public func withType(_ newType: TypeSyntax) -> TypeAnnotationSyntax {
    let (root, newData) = data.replacingChild(newType.raw,
                                              at: Cursor.type)
    return TypeAnnotationSyntax(root: root, data: newData)
  }

}

/// MARK: TypeIdentifierSyntax Data

/// MARK: TypeIdentifierSyntax API

public struct TypeIdentifierSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var typeNameToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.typeNameToken))
  }

  public func withTypeNameToken(_ newTypeNameToken: TokenSyntax) -> TypeIdentifierSyntax {
    guard case .token(.identifier, _, _, _) = newTypeNameToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newTypeNameToken.raw,
                                              at: Cursor.typeNameToken)
    return TypeIdentifierSyntax(root: root, data: newData)
  }

  public var genericArgumentClause: GenericArgumentClauseSyntax {
    return GenericArgumentClauseSyntax(root: root, data: data.cachedChild(at: Cursor.genericArgumentClause))
  }

  public func withGenericArgumentClause(_ newGenericArgumentClause: GenericArgumentClauseSyntax) -> TypeIdentifierSyntax {
    let (root, newData) = data.replacingChild(newGenericArgumentClause.raw,
                                              at: Cursor.genericArgumentClause)
    return TypeIdentifierSyntax(root: root, data: newData)
  }

  public var periodToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.periodToken))
  }

  public func withPeriodToken(_ newPeriodToken: TokenSyntax) -> TypeIdentifierSyntax {
    guard case .token(.period, _, _, _) = newPeriodToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newPeriodToken.raw,
                                              at: Cursor.periodToken)
    return TypeIdentifierSyntax(root: root, data: newData)
  }

  public var typeIdentifier: TypeIdentifierSyntax {
    return TypeIdentifierSyntax(root: root, data: data.cachedChild(at: Cursor.typeIdentifier))
  }

  public func withTypeIdentifier(_ newTypeIdentifier: TypeIdentifierSyntax) -> TypeIdentifierSyntax {
    let (root, newData) = data.replacingChild(newTypeIdentifier.raw,
                                              at: Cursor.typeIdentifier)
    return TypeIdentifierSyntax(root: root, data: newData)
  }

}

/// MARK: WhereClauseSyntax Data

/// MARK: WhereClauseSyntax API

public struct WhereClauseSyntax: _SyntaxBase {
  let root: SyntaxData
  unowned let data: SyntaxData

  public var whereToken: TokenSyntax {
    return TokenSyntax(root: root, data: data.cachedChild(at: Cursor.whereToken))
  }

  public func withWhereToken(_ newWhereToken: TokenSyntax) -> WhereClauseSyntax {
    guard case .token(.kw_where, _, _, _) = newWhereToken.raw.kind else {
      fatalError("incorrect token kind")
    }

    let (root, newData) = data.replacingChild(newWhereToken.raw,
                                              at: Cursor.whereToken)
    return WhereClauseSyntax(root: root, data: newData)
  }

  public var whereExpr: ExprSyntax {
    return ExprSyntax(root: root, data: data.cachedChild(at: Cursor.whereExpr))
  }

  public func withWhereExpr(_ newWhereExpr: ExprSyntax) -> WhereClauseSyntax {
    let (root, newData) = data.replacingChild(newWhereExpr.raw,
                                              at: Cursor.whereExpr)
    return WhereClauseSyntax(root: root, data: newData)
  }

}

