
%{
  # -*- mode: Swift -*-
  from gyb_syntax_support import *
  NODE_MAP = create_node_map()
  # Ignore the following admonition; it applies to the resulting .swift file only
}%
//// Automatically Generated From SyntaxBuilders.swift.gyb.
//// Do Not Edit Directly!
//===------------ SyntaxBuilders.swift - Syntax Builder definitions -------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2017 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

% for node in SYNTAX_NODES:
%   if node.is_buildable():
%     Builder = node.name + "Builder"
public class ${Builder} {
  private var layout = [
%     for child in node.children:
    ${make_missing_swift_child(child)},
%     end
  ]
%     for child in node.children:
%       child_node = NODE_MAP.get(child.syntax_kind)
%       raw_ref = "layout[%s.Cursor.%s]" % (node.name, child.swift_name)
%       if child_node and child_node.is_syntax_collection():
%         child_elt = child_node.collection_element_name
%         child_elt_type = child_node.collection_element_type

  public func add${child_elt}(_ elt: ${child_elt_type}) -> ${Builder}  {
    ${raw_ref} = ${raw_ref}.appending(elt.raw)
    return self
  }
%       else:

  public func use${child.name}(
    _ ${child.swift_name}: ${child.type_name}) -> ${Builder}  {
    ${raw_ref} = ${child.swift_name}.raw
    return self
  }
%       end
%     end

  func build() -> ${node.name} {
    return SyntaxFactory.make(.node(.${node.swift_syntax_kind},
                                    layout, .present))
  }
}

%   end
% end